\section{Decomposition 4: Av2, UC12, UC25, UC26, UC27}

\subsection{Elements/Subsystem to decompose/expand}
    In this run we decompose/expand ...
    decompose the ApplicationContainer component
    expand the application execution subsystem


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{Av2}: Application failure
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC12}: Perform actuation command \\
              Short description of the UC.
        \item \emph{UC13}: Configure pluggable device \\
              Short description of the UC.
        \item \emph{UC25}: Access topology and available devices \\
              Short description of the UC.
        \item \emph{UC24}: Consult historical data \\
              Short description of the UC.
        \item \emph{UC26}: Send application command or message to external front-end \\
              Short description of the UC.
        \item \emph{UC27}: Receive application command or message from external front-end \\
              Short description of the UC.
    \end{itemize}


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    \paragraph{Av2: Detection of failures}
        The system is able to autonomously detect failures of its individual
        application execution components, failing applications, and failing application containers. \\
        Upon detection, a SIoTIP system administrator is notified. \\
        The failure of an internal application execution component is detected within 30 seconds.
        Detection of failed hardware or crashed software happens within 5 seconds.
        SIoTIP system administrators are notified within 1 minute.\\

        *) APPLICATION CRASH
        -> Monitor

        ApplicationContainer becomes:
            ApplicationManager: that does management of instances and communication
            with other components

            ApplicationInstance: is a container/sandbox that has
            1 running application instance
            = application execution component
            ?? run on different hardware maybe?

            ContainerMonitor: that monitors the ContainerInstance instances

        ContainerMonitor -> ApplicationInstance: boolean check()
        ApplicationInstance -> ContainerMonitor: void applicationCrashed(id applicationInstanceID)

        *) OR APPLICATION EXECUTION COMPONENT CRASH
        -> we say container has crashed/failed when the following has no response:
        ContainerMonitor -> ApplicationInstance: boolean check()
        is ok????

        *) Detection of failed hardware
        TODO ask what hardware?? separate hardware that runs application instances?

        *) Send notification

    \paragraph{Av2: Resolution of application failures}
        In case of application crash, the system autonomously restarts failed applications.
        If part of an application fails, the remaining parts remain operational,
        possibly in a degraded mode (graceful degradation). \\
        After 3 failed restarts the application is suspended, and the
        application developer and customer organisation are notified within 5 minutes.\\
        Application fails -> ContainerMonitor detects this -> ApplicationInstance: restart
        3 failed restarts -> suspend app and send notification

        *) Graceful degradation:
        -> send message to other parts to notify of failed part

    \paragraph{Av2: Resolution of application execution component failures}
        In case of failure of application execution components or an application
        container, a system administrator is notified. \\
        SIoTIP system administrators are notified within 1 minute.\\
        Solution for the problem.
        ApplicationInstance failure -> send notification to system administrator
        SIoTIP system administrators are notified within 1 minute.

    \paragraph{Av2: Failures do not impact other applications or other functionality of the system}
        This does not affect other applications that are executing on the Online
        service or SIoTIP gateway. This does not affect the availability of
        other functionality of the system, such as the dashboards. \\
        Applications fail independently: they are executed within their own
        container to avoid application crashes to affect other applications.\\
       -> we already have this, the ApplicationContainer component.

    \paragraph{Av2: Up-time of application execution subsystem}
        The subsystem for executing applications in the Online Service must
        have a guaranteed minimal up-time. The subsystem for executing
        applications in the Online Service must be available
        99\% of the time, measured per month. \\
        Solution for the problem.
        Subsystem = ApplicationManager + ApplicationContainer + new components ???


\subsection{Instantiation and allocation of functionality}
    This section describes the new components which instantiate our solutions described
    in the section above and how components are deployed on physical nodes. \\
    Unless stated otherwise the responsibilities assigned in the first decomposition are unchanged.

    \paragraph{Decomposition}
        Figure \ref{fig:FIGURELABEL} shows the components resulting from the
        decomposition in this run.

        \begin{figure}[!h]
        	\centering
            %\includegraphics[width=1\textwidth]{IMAGE FILE NAME}
        	\missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram of this decomposition}
        	\caption{Component-and-connector diagram of this decomposition.}
            \label{fig:FIGURELABEL}
        \end{figure}

        The responsibilities of the components are as follows:

    \subparagraph{Component}
        Short description of its responsibilities. (Relevant QA or UC)


    % \paragraph{Behaviour}
        % USEFUL SEQUENCE DIAGRAMS FOR CHOSEN USE CASES


    \paragraph{Deployment}
        Figure \ref{fig:FIGURELABEL} shows the allocation of components
        to physical nodes.

        \begin{figure}[!h]
        	\centering
        	%\includegraphics[width=0.8\textwidth]{IMAGE FILE NAME}
        	\missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
        	\caption{Deployment diagram of this decomposition.}
            \label{fig:FIGURELABEL}
        \end{figure}


\subsection{Interfaces for child modules}\label{add2-interfaces}
    This section describes the interfaces assigned to the components defined
    in the section above. Per interface, we list its methods by means of its
    syntax. The data types used in these interfaces are defined in the following section. \\

    Each method shows which (part of a) quality attribute or use case caused
    a need for the method. However, this does not mean that a method is
    only to be used to satisfy that quality  attribute or use case, it could
    be used for other causes not yet mentioned here.

    The interfaces and methods defined here are to be seen as an
    extension of the interfaces defined in previous sections, unless
    explicitly stated otherwise.

    \subsubsection{Component}
        \begin{itemize}
            \item InterfaceName
            \begin{itemize}
                \item \texttt{void methodName(.. parameters ..)}
                \begin{itemize}
                    \item Effect: Short description of the method
                    \item Created for: Reason for the addition of this method.
                \end{itemize}
            \end{itemize}
        \end{itemize}

\subsection{Data type definitions}
    This section defines new data types that are used in the interface descriptions above.

    \paragraph{DataType}
        Description of data type
