\section{Decomposition 4: Av2, UC12, UC25, UC26, UC27 (application execution subsystem)}


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{Av2}: Application failure
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC12}: Perform actuation command \\
              Short description of the UC.
        \item \emph{UC13}: Configure pluggable device \\
              Short description of the UC.
        \item \emph{UC25}: Access topology and available devices \\
              Short description of the UC.
        \item \emph{UC24}: Consult historical data \\
              Short description of the UC.
        \item \emph{UC26}: Send application command or message to external front-end \\
              Short description of the UC.
        \item \emph{UC27}: Receive application command or message from external front-end \\
              Short description of the UC.
    \end{itemize}

    \paragraph{Rationale}
        At this point the remaining drivers were Av1, Av2, and P1,
        which all had medium priority. We chose decompositions 4, 5,
        and 6 based on the priorities of the use cases that are related to the quality attributes. \\
        The related use cases from now on are the ones that would use components
        that are going to be changed in the decomposition.


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    % Pattern: Container
    %     Define a container to provide the execution environment for a
    %     component that supports the necessary technical infrastructure
    %     to integrate components into application-specific usage scenarios,
    %     and on specific system platforms, without tightly coupling
    %     the components with the applications or platforms.
    %
    %     Use the container to initialize and provide the runtime context for the
    %     components it manages. Define operations that enable component
    %     objects to access their connections to ports of other components,
    %     as well as to access common middleware services such as persistence,
    %     event notification, transactions, replication, load balancing,
    %     and security.

    \paragraph{Av2: Detection of failures}
        The system is able to autonomously detect failures of its individual
        application execution components, failing applications, and failing application containers. \\
        Upon detection, a SIoTIP system administrator is notified. \\
        The failure of an internal application execution component is detected within 30 seconds.
        Detection of failed hardware or crashed software happens within 5 seconds.
        SIoTIP system administrators are notified within 1 minute.\\

        To detect failures, we made use of the \texttt{Container} pattern.
        The application execution subsystem is composed of:
        \begin{itemize}
            \item \texttt{ApplicationContainer}
            \item \texttt{ApplicationContainerMonitor}
            \item \texttt{ApplicationContainerManager}
            \item \texttt{ApplicationExecutionSubsystemMonitor}
        \end{itemize}

        The \texttt{ApplicationContainer}s are deployed in groups on different nodes.

        \texttt{ApplicationContainer}: is a container/sandbox that has 1 running application instance
        \texttt{ApplicationContainerMonitor}: monitors the \texttt{ApplicationContainer} instances

        To detect failing applications, \texttt{ApplicationContainer} and \texttt{ApplicationContainerMonitor}
            ApplicationContainer -> ApplicationContainerMonitor: void applicationCrashed(id applicationInstanceID)

        To detect failling application containers, \texttt{ApplicationContainerMonitor}
            ApplicationContainerMonitor -> ApplicationContainer: Echo ping()
            -> we say container has crashed/failed when the following has no response:

        To detect failures of individual application execution components,
        This means that one of \texttt{ApplicationContainer}, \texttt{ApplicationContainerMonitor}, \texttt{ApplicationContainerManager} crashed.
        If the \texttt{ApplicationContainer} failed, then the \texttt{ApplicationContainerMonitor} would detect this.
        If one of the other two components failed, the \texttt{ApplicationExecutionSubsystemMonitor} is put in place to detect this.

        These components will be deployed on the Online Service and on gateways.
        Since gateways are weaker machines than the ones on the Online Service,
        the ApplicationContainer can be confgured differently for gateways.
        The ApplicationContainers will then have stricter limits on
        resources used of the node they are working on.

        % TODO: see after the decomposition if this is useful to us
        % (usage of memory, number of served requestst and so ) and some monitoring
        % system (component), that monitors container sends regularly request to this endpoint
        % and  collect this information about aplications

        % Application executing on Online Service failed & Application executing on Gateway failed
        %     -> ApplicationInstance has failed AND ApplicationContainer is still ok
        %        so ApplicationContainer sends message "application instance X has crashed"
        %
        %
        % Container of application instance crashed
        %     -> ApplicationContainer has failed
        %     -> ApplicationContainerMonitor notices this (no reply to pings maybe)
        %     -> ApplicationContainerMonitor sends a command to the ApplicationContainerManager to restart or ...
        %
        % One of the internal application execution components crashed
        %     Application execution subsystem = ApplicationContainer + ApplicationContainerMonitor + ApplicationContainerManager

    \paragraph{Av2: Resolution of application failures and application execution component failures}
        In case of application crash, the system autonomously restarts failed applications.
        If part of an application fails, the remaining parts remain operational,
        possibly in a degraded mode (graceful degradation). \\
        After 3 failed restarts the application is suspended, and the
        application developer and customer organisation are notified within 5 minutes.\\

        In case of failure of application execution components or an application
        container, a system administrator is notified. \\
        SIoTIP system administrators are notified within 1 minute.\\

        When an application instance fails, the ApplicationContainerMonitor detects this and
        sends a command to the ApplicationContainerManager to restart the application instance.
        The ApplicationContainerMonitor keeps track of how many times the
        application instance has been restarted after a failure. After 3 failed restarts, the monitor
        send a command to the ApplicationContainerManager to suspend the application instance and send
        a notification to the application developers of the application and to the
        affected customer organisaiton. Also, to achieve graceful degradation,
        the ApplicationContainerManager notifies other parts of the application instance
        of its suspension.

        If one of the components of the application execution subsystem fails,
        a SIoTIP system administrator is notified.


    \paragraph{Av2: Failures do not impact other applications or other functionality of the system}
        This does not affect other applications that are executing on the Online
        service or SIoTIP gateway. This does not affect the availability of
        other functionality of the system, such as the dashboards. \\
        Applications fail independently: they are executed within their own
        container to avoid application crashes to affect other applications.\\

        Each ApplicationContainer contains one application instance. If an application fails,
        then this will be handled by the application execution subsystem so this
        does not affect any other application or other functionality of the system.
        The ApplicationContainers are constructed such that failures of applications
        do not affect the containers. The ApplicationContainers are to be deployed
        on different nodes alone or grouped with other containers. Write something here.


    % TODO: how do you guarantee this?
    % \paragraph{Av2: Up-time of application execution subsystem}
    %     The subsystem for executing applications in the Online Service must
    %     have a guaranteed minimal up-time. The subsystem for executing
    %     applications in the Online Service must be available
    %     99\% of the time, measured per month. \\
    %     Solution for the problem.
    %
    %     containers can have replicas, for example every container has 3 replicas and
    %     when one crash  there has to be sometnig that find out that there are
    %     just 2 replicas now and it is needed to create new replica.
    %
    %     There is also needed component for load balancing.


        UC12:
            DEVELOPERS WRITE THIS: command = "on"
            actuators = getActuatorsOfType("lightswitch")
            foreach (actuator) {
                actuator.command("on")
            }

            WE NEED TO CONVERT "on" TO A COMMAND THAT THE ACTUATOR UNDERSTANDS
            "on" => "turnOn"
            "on" => "lightOn"
            "on" => "switch"

            1. An application indicates that it wants one or more pluggable devices to perform an actuation command
                from client application:
                    ApplicationClient -> ApplicationFacade:           interface DeviceMgmt:       void sendActuationCommand(List<PluggableDeviceID> devices, string command)
                        Effect: Sends a command for a list of actuators to ApplicationManagementLogic for construction of the actuation command messages.
                        \item Created for: UC12.1
                    ApplicationFacade -> ApplicationManagementLogic:  interface AppDeviceMgmt:  void sendActuationCommand(List<PluggableDeviceID> devices, string command)
                        Effect: Sends a command for a list of actuators to ApplicationManagementLogic for construction of the actuation command messages.
                        \item Created for:UC12.1

                from application on online service:
                    ApplicationContainer -> ApplicationManagementLogic: interface AppDeviceMgmt: void sendActuationCommand(List<PluggableDeviceID> devices, string command)
                        Effect: Sends a command for a list of actuators to ApplicationManagementLogic for construction of the actuation command messages.
                        \item Created for:UC12.1

                from application on gateway: SKIP STEP 2
                    GW/ApplicationContainer -> GW/DeviceCommandConstructor: interface Commands: void sendActuationCommand(List<PluggableDeviceID> device, string commandName)
                        Effect: Sends a command for a list of actuators to DeviceCommandConstructor on the Gateway for construction of the actuation command messages.
                        \item Exceptions: UnknownCommandException
                        \item Created for: UC12 - commands from applications on gateways
                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: Map<PluggableDeviceID, string> getFormattingSyntaxForDevices(List<PluggableDeviceID> devices)
                        Effect: Retrieves the specific formatting syntax for a list of pluggable devices from the DeviceManager.
                        \item Created for: UC12 - commands from applications on gateways
                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: void sendActuationCommand(Map<PluggableDeviceID, string> commandsForDevices)
                        Effect: Sends correctly constructed actuation commands for a group of actuators to the DeviceManager.
                        \item Created for: UC12 - commands from applications on gateways


            2. The system
                -constructs the actuation command message according to the specific formatting syntax for the involved pluggable device(s)
                    ApplicationManagementLogic -> DeviceCommandConstructor:  interface Commands:  list<string> constructCommandsForDevices(string command, List<PluggableDeviceID> devices)
                        Effect: Constructs actuation commands according to the specific formatting syntax for the given pluggable devices. The command 'command' is a command that application developers use for a group of devices.
                        \item Exceptions: UnknownCommandException
                        \item Created for: UC12.2
                    DeviceCommandConstructor -> DeviceDB: interface AppDeviceMgmt: Map<PluggableDeviceID, string> getFormattingSyntaxForDevices(List<PluggableDeviceID> devices)
                        Effect: Retrieves the specific formatting syntax for a list of pluggable devices.
                        \item Created for: UC12.2-3

                -sends the command message to the intended pluggable device(s).
                    DeviceCommandConstructor -> DeviceDB:      interface AppDeviceMgmt: Map<PluggableDeviceID, GatewayInfo> getGatewaysForDevices(List<PluggableDeviceID> devices)
                        Effect: Returns a map of PluggableDevices with the gateways they are connected to.
                        \item Created for: UC12.2
                    DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: void sendActuationCommand(List<PluggableDeviceID> actuators, List<string> commands)
                        Effect: Sends an actuation command to an actuator.
                        \item Created for: UC12.2

            3. The pluggable device(s) receive(s) the actuation command message and perform(s) the contained actuation command.
                    DeviceManager -> Mote: interface DeviceMgmt: void sendActuationCommand(PluggableDeviceID device, string commandName)
                    Effect: Sends command from GatewayFacade to Mote for the pluggable device
                        \item Created for: UC12.3
                    Mote -> PluggableDevice: interface Actuate:    void sendActuationCommand(string commandName)


        TODO step 5
        TODO MONIKA QUESTION SHE DOES NOT LIKE THIS
        UC13:
            1. The primary actor specifies that it wants to set a configuration parameter of a pluggable device.

                from client application:
                    ApplicationClient -> ApplicationFacade:           interface DeviceMgmt:       void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device.
                        \item Created for: UC13.1
                    ApplicationFacade -> ApplicationManagementLogic:  interface AppDeviceMgmt:  void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device.
                        \item Created for: UC13.1

                from application on online service:
                    ApplicationContainer -> ApplicationManagementLogic: interface AppDeviceMgmt: void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device.
                        \item Created for: UC13.1

                from application on gateway: SKIP STEPS 2 AND 3
                    GW/ApplicationContainer -> GW/DeviceCommandConstructor: interface Commands: void verifyAndConstructConfigurationsForDevice(PluggableDevideID pID, Map<string, string> config)
                        Effect: Verifies the configuration parameters for a pluggable device. It the parameters have been successfuly verified,
                                constructs a reconfiguration command according to the specific formatting syntax for the pluggable device and sends it to the DeviceManager if everything is correct.
                        \item Exceptions: UnkownConfigurationParameterException
                        \item Created for: UC13 - configuration commands from applications on gateways

                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: string getPossibleConfigurationParametersForDevice(PluggableDeviceID pID)
                        Effect: Retrieves the possible configuration parameters for a pluggable device.
                        \item Created for: UC13 - configuration commands from applications on gateways

                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: Map<PluggableDeviceID, string> getFormattingSyntaxForDevices(List<PluggableDeviceID> devices)
                        Effect: Retrieves the specific formatting syntax for a list of pluggable devices.
                        \item Created for: UC13 - configuration commands from applications on gateways

                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device. The DeviceManager first determines whether the pluggable device needs to be reconfigured. To do this,
                                it checks the data it has about configurations set by other applications on the pluggable device. If the device can be reconfigured, then the configuration
                                command is propagated to the pluggable device.
                        \item Created for: UC13 - configuration commands from applications on gateways


            2. The system verifies that the value of the configuration parameter is valid for the device (for example, a sensor which provides temperature information may have hardware limits on the sampling frequency).

                    ApplicationManagementLogic -> DeviceCommandConstructor: interface Commands: void verifyAndConstructConfigurationsForDevice(PluggableDevideID pID, Map<string, string> config)
                        Effect: Verifies the configuration parameters for a pluggable device. It the parameters have been successfuly verified,
                                constructs a reconfiguration command according to the specific formatting syntax for the pluggable device and sends it to the DeviceManager if everything is correct.
                        \item Exceptions: UnkownConfigurationParameterException
                        \item Created for: UC13.2-3

                    DeviceCommandConstructor -> DeviceDB: interface AppDeviceMgmt: string getPossibleConfigurationParametersForDevice(PluggableDeviceID pID)
                        Effect: Retrieves the possible configuration parameters for a pluggable device.
                        \item Created for: UC13.2

                    DeviceCommandConstructor -> DeviceDB: interface AppDeviceMgmt: Map<PluggableDeviceID, string> getFormattingSyntaxForDevices(List<PluggableDeviceID> devices)
                        Effect: Retrieves the specific formatting syntax for a list of pluggable devices.
                        \item Created for: UC13 - commands from applications on gateways


            3. The system determines whether the pluggable device needs to be reconfigured, and if so,
               constructs a reconfiguration command according to the specific formatting syntax for the pluggable device and sends it to the pluggable device.

                    DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device. The DeviceManager first determines whether the pluggable device needs to be reconfigured. To do this,
                                it checks the data it has about configurations set by other applications on the pluggable device. If the device can be reconfigured, then the configuration
                                command is propagated to the pluggable device.
                        \item Created for: UC13.3

            4. The system updates the internal configuration of the pluggable device.
                    DeviceManager -> Mote: interface DeviceMgmt: void setConfig(...)

            5. The system informs the primary actor that the reconfiguration was done successfully.


        UC24:
            1. The primary actor indicates that it wants to consult a specified collection of historical data in
                a specified timeframe.
                ApplicationClient -> ApplicationFacade: interface AppData:
                                                void getHistoricalData(DateTime from, DateTime to, int custOrgID)
                ApplicationFacade -> ApplicationManager: interface FrontEndAppMgmt:
                                                void getHistoricalData(DateTime from, DateTime to, int custOrgID)
            2. The system determines from which pluggable devices the data is required and looks up the data.
                 ????
            3. The system presents the primary actor with the requested historical overview, e.g. as a table.
                ApplicationManager -> DeviceDataScheduler: interface RequestData:
                                      HistoricalData getHistoricalData(List<PluggableDeviceID> id,DateTime from, DateTime to)
                DeviceDataScheduler -> PluggableDeviceDB: interface DeviceData:
                                      HistoricalData getHistoricalData(List<PluggableDeviceID> id,DateTime from, DateTime to)

        UC25:
            1. The primary actor indicates that it wants an overview of the topology.
                ApplicationClient -> ApplicationFacade: interface TopologyOverview
                                                               void getTopologyOverview(int custOrgID)
            2. The system looks up the pluggable devices that are available to the customer organisation
           that owns the primary actor, and composes a view on the topology including these pluggable devices.
                ApplicationFacade -> ApplicationManager: interface FrontEndAppMgmt: List<RoomTopology> getTopology(int custOrgID)
                TopologyManager -> DeviceDB: interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID)
            3. The system presents the topology view to the primary actor.

        UC26:
            1. The primary actor indicates it wants to send an application command or message to an external
                front-end and specifies the destination (e.g., as an application identifier for SIoTIP applications,
                or a hostname and port for external systems).
                Map<string, string> destination = type of destination, value
                Map<string, string> requestType = Message/Command, value
                GWApplicationContainer -> GWApplicationContainerManager: interface AppRequests:
                                                   void sendRequest(Map<string, string> destination, Map<string, string> requestType)
                       Effect: Command or message is sent to  to an external front-end
                       \item Created for: UC26.1
                GWApplicationContainerManager -> GWDeviceCommandConstructor: interface AppRequests:
                                                      void sendRequest(Map<string, string> destination, Map<string, string> requestType)
                         Effect: Command or message is sent to  to an external front-end
                       \item Created for: UC26.1
            2. The system checks that the primary actor is allowed to send to the specified destination.
            AccesRightManager???
            3. If the primary actor is allowed to send to the destination, and if the destination is another
                application, the system delivers the application command to that destination (Include: UC27:
                Receive application command or message from external front-end).
                TODO: add containers and monitor to gatewayfacade
                GWDeviceCommandConstructor -> DeviceCommandConstructor: interaface Actuation
                                        void sendRequest(Map<string, string> destination,Map<string, string> requestType)
                See UC27
            4. The system informs the primary actor that the message was sent.

       UC27:
       Comment from professor:
           UC27 (just as UC26) deals with communication between different parts of the same application (including messages coming from front-ends).

        1. The system receives an application command or message for a SIoTIP application.
            DeviceCommandConstructor -> ApplicationContainerManager: interface AppRequests:
                                                 void rcvApplicationRequest(Map<string, string> destination,Map<string, string> requestType)
                   Effect: ApplicationContainerManager receives message or application command
                   \item Created for: UC27.1

        2. The system checks that the destination is available.
            ApplicationContainerManager -> ApplicationContainerMonitor: interface Availability:
                                                bool checkDestination(Map<string, string>  destination)
                   Effect: Return true if destionation is available
                   \item Created for: UC27.2

            ApplicationContainerMonitor -> ApplicationContainer: interface AppInstanceMgmt:
            Map<Parameters,String> checkApplicationAvailability(AppInstanceID id)
                    Effect: Return parameters and their values of application
                   \item Created for: UC27.2

        3. If the destination is available, the system delivers the message to the destination application.
            ApplicationContainerManager -> ApplicationContainer: interface AppRequests
                               void rcvApplicationRequest(Map<string, string> destination,Map<string, string> requestType)
                   Effect: Receive message or application command
                   \item Created for: UC27.3

\subsection{Instantiation and allocation of functionality}
    This section lists the new components which instantiate our solutions
    described in the section above. For each component we note the quality
    attribute or use case that prompted us to create it. Descriptions about
    the components can be found under chapter \ref{ch:elements-datatypes}. \\

    \begin{itemize}
        \item Component: ApplicationClient
        \item Component: ApplicationFacade
        \item Component: DeviceCommandConstructor
        \item Component: ApplicationContainer
        \item Component: ApplicationContainerManager
        \item Component: ApplicationContainerMonitor
        \item Component: GWDeviceCommandConstructor
        \item Component: GWApplicationContainer
        \item Component: GWApplicationContainerManager
        \item Component: GWApplicationContainerMonitor
    \end{itemize}


\subsection{Interfaces for child modules}
    This section lists new interfaces assigned to the components defined
    in the section above. Detailed information about each interface and
    its methods can be found under chapter \ref{ch:elements-datatypes}. \\

    \subsubsection{DeviceCommandConstructor}
        \begin{itemize}
            \item Actuation
        \end{itemize}

    \subsubsection{GWDeviceCommandConstructor}
        \begin{itemize}
            \item AppRequests
        \end{itemize}

   \subsubsection{ApplicationContainer}
        \begin{itemize}
            \item AppRequests
        \end{itemize}

    \subsubsection{ApplicationContainerManager}
        \begin{itemize}
            \item AppRequests
        \end{itemize}

    \subsubsection{ApplicationFacade}
        \begin{itemize}
            \item AppMgmt
        \end{itemize}

    \subsubsection{ApplicationFacade}
        \begin{itemize}
            \item DeviceMgmt
        \end{itemize}

    \subsubsection{ApplicationFacade}
        \begin{itemize}
            \item TopologyOverview
        \end{itemize}


\subsection{Data type definitions}
    This section lists the new data types introduced during this decomposition.

    \begin{itemize}
        \item Parameter: Parameter of application e.g. usage of memory, handle requests...
    \end{itemize}
