\section{Decomposition 4: Av2, UC12, UC25, UC26, UC27 (application execution subsystem)}


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{Av2}: Application failure
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC12}: Perform actuation command \\
              Short description of the UC.
        \item \emph{UC13}: Configure pluggable device \\
              Short description of the UC.
        \item \emph{UC25}: Access topology and available devices \\
              Short description of the UC.
        \item \emph{UC24}: Consult historical data \\
              Short description of the UC.
        \item \emph{UC26}: Send application command or message to external front-end \\
              Short description of the UC.
        \item \emph{UC27}: Receive application command or message from external front-end \\
              Short description of the UC.
    \end{itemize}

    \paragraph{Rationale}
        At this point the remaining drivers were Av1, Av2, and P1,
        which all had medium priority. We chose decompositions 4, 5,
        and 6 based on the priorities of the use cases that are related to the quality attributes. \\
        The related use cases from now on are the ones that would use components
        that are going to be changed in the decomposition.


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    \paragraph{Av2: Detection of failures}
        The system is able to autonomously detect failures of its individual
        application execution components, failing applications, and failing application containers. \\
        Upon detection, a SIoTIP system administrator is notified. \\
        The failure of an internal application execution component is detected within 30 seconds.
        Detection of failed hardware or crashed software happens within 5 seconds.
        SIoTIP system administrators are notified within 1 minute.\\

        *) APPLICATION CRASH
        -> Monitor

        ApplicationContainer becomes:
            ApplicationManager: that does management of instances and communication
            with other components

            ApplicationInstance: is a container/sandbox that has
            1 running application instance
            = application execution component
            ?? run on different hardware maybe?

            ContainerMonitor: that monitors the ContainerInstance instances

        ContainerMonitor -> ApplicationInstance: boolean check()
        ApplicationInstance -> ContainerMonitor: void applicationCrashed(id applicationInstanceID)

        *) OR APPLICATION EXECUTION COMPONENT CRASH
        -> we say container has crashed/failed when the following has no response:
        ContainerMonitor -> ApplicationInstance: boolean check()
        is ok????

        *) Detection of failed hardware
        TODO ask what hardware?? separate hardware that runs application instances?

        *) Send notification

    \paragraph{Av2: Resolution of application failures}
        In case of application crash, the system autonomously restarts failed applications.
        If part of an application fails, the remaining parts remain operational,
        possibly in a degraded mode (graceful degradation). \\
        After 3 failed restarts the application is suspended, and the
        application developer and customer organisation are notified within 5 minutes.\\
        Application fails -> ContainerMonitor detects this -> ApplicationInstance: restart
        3 failed restarts -> suspend app and send notification

        *) Graceful degradation:
        -> send message to other parts to notify of failed part
        we ca have component responsible for controlling state of application
        and can start, stop or restart application. 
        
        

    \paragraph{Av2: Resolution of application execution component failures}
        In case of failure of application execution components or an application
        container, a system administrator is notified. \\
        SIoTIP system administrators are notified within 1 minute.\\
        Solution for the problem.
        ApplicationInstance failure -> send notification to system administrator
        SIoTIP system administrators are notified within 1 minute.
        application return diferent metrics 

        (usage of memory, number of served requestst and so ) and some monitoring 
        system (component), that monitors container sends regularly request to this endpoint 
        and  collect this information about aplications

    \paragraph{Av2: Failures do not impact other applications or other functionality of the system}
        This does not affect other applications that are executing on the Online
        service or SIoTIP gateway. This does not affect the availability of
        other functionality of the system, such as the dashboards. \\
        Applications fail independently: they are executed within their own
        container to avoid application crashes to affect other applications.\\
       -> we already have this, the ApplicationContainer component.

    \paragraph{Av2: Up-time of application execution subsystem}
        The subsystem for executing applications in the Online Service must
        have a guaranteed minimal up-time. The subsystem for executing
        applications in the Online Service must be available
        99\% of the time, measured per month. \\
        Solution for the problem.
        Subsystem = ApplicationManager + ApplicationContainer + new components ???
        
        containers can have replicas, for example every container has 3 replicas and 
        when one crash  there has to be sometnig that find out that there are 
        just 2 replicas now and it is needed to create new replica.
        
        There is also needed component for load balancing.
        
        UC12:
            1. An application indicates that it wants one or more pluggable devices 
            to perform an actuation command (e.g., sound all buzzers on the first floor).
            ApplicationClient -> ApplicationFacade: interface AppMgmt: sendCommand(DeviceDataID id, MoteID id, Map<String,String> data) 
            ApplicationFacade -> CommandHandler: interface AppMgmt: sendCommand(DeviceDataID id, MoteID id, Map<String,String> data)
            
            2. The system 
                -constructs the actuation command message according to the specific formatting syntax
                for the involved pluggable device(s)
                CommandHandler -> ApplicationManager: 
                                                void sendCommand(DeviceDataID id, MoteID id, Map<String,String> data)
                                                   Json message createData(DeviceDataID id, MoteID id, Map<String,String> data)
                                                     
                -sends the command message to the intended pluggable device(s).
                    
                    ApplicationManager -> GatewayFacade: interface AppDeviceMgmt: 
                                                            void sendCommand(List<int> acctuators, Json message)
            
            3. The pluggable device(s) receive(s) the actuation command message
               and perform(s) the contained actuation command.
                    GatewayFacade -> MoteFacade: interface DeviceMgmt: sendCommand(Json messsage)
                    MoteFacade -> PluggableDeviceFacade: interface Actuate: 
                                                            void sendActuationCommand(String commandName)
            
            Remarks:
            The topology may be used to determine the set of actuators that need 
            to perform the actuation command.
                ApplicationManager -> TopologyManager: interface TopologyMgmt:
                                                             List<int> determineAcuators(Json message).
            
            Note that an explicit acknowledgement is not sent by the pluggable device. However, 
            the pluggable device will regularly send its data, including state information, to the system 
            (cf. UC11:Send pluggable device data). This state will reflect the outcome of the actuation command
            (e.g., indicating that a buzzer is on). Furthermore, the application will be notified when
            pluggable devices fail (cf. UC14: Send heartbeat).
                PluggableDeviceData -> MoteFacade: interface DeviceData: void rcvData(PluggableDeviceID pID, DeviceData data)
                MoteFacade -> GatewayFacade: interface DeviceData: void rcvData(PluggableDeviceID pID, DeviceData data)
                GatewayFacade -> ApplicationManager: interface AppMgmt: sendDeviceStatus(PluggableDeviceID pID, String status)

                
                
        UC13: 
            1. The primary actor specifies that it wants to set a configuration parameter of a pluggable
            device.
                ApplicationClient -> ApplicationFacade: interface AppMgmt:
                                                        void setConfiguration(PluggableDevideID id, Map<String,String> parameters)
                ApplicationFacade -> ApplicationManager: interface DeviceMgmt:
                                                        void setConfiguration(PluggableDevideID id, Map<String,String> parameters)
            
                
            2. The system verifies that the value of the configuration parameter is valid for the device (for
               example, a sensor which provides temperature information may have hardware limits on the
               sampling frequency).
               ApplicationManager -> DeviceDB: interface AppDeviceMgmt: bool checkDeviceParameter(PluggableDeviceID):
                                                      
            3. The system determines whether the pluggable device needs to be reconfigured, and if so,
               constructs a reconfiguration command according to the specific formatting syntax for the
               pluggable device and sends it to the pluggable device. ????how
            
            4. The system updates the internal configuration of the pluggable device.
                ApplicationManager -> Datatase: interface AppMgmt:
                                                     void setConfiguration(PluggableDeviceID id, Map<String,String> parameters) 
            
            5. The system informs the primary actor that the reconfiguration was done successfully.  
                ApplicationManager -> NotificationManager: interface Notify: notify(int userID, string message)  
         
            Alternative scenarios:
            2a. If the value is invalid for the pluggable device, the system informs the application via an
                exception. The use case ends.
                - first exception
            Remarks:
                Note that different applications may have different preferences for a single pluggable device
        
        UC24:
            1. The primary actor indicates that it wants to consult a specified collection of historical data in
                a specified timeframe.
                ApplicationClient -> ApplicationFacade: interface AppData:
                                                void getHistoricalData(DateTime from, DateTime to, int custOrgID)
                ApplicationFacade -> ApplicationManager: interface Apps:
                                                void getHistoricalData(DateTime from, DateTime to, int custOrgID)
            2. The system determines from which pluggable devices the data is required and looks up the data.
                 ????
            3. The system presents the primary actor with the requested historical overview, e.g. as a table.
                ApplicationManager -> DeviceDataScheduler: interface RequestData:
                                      HistoricalData getHistoricalData(List<PluggableDeviceID> id,DateTime from, DateTime to)
                DeviceDataScheduler -> PluggableDeviceDB: interface DeviceData:
                                      HistoricalData getHistoricalData(List<PluggableDeviceID> id,DateTime from, DateTime to) 
                
        UC25:
            1. The primary actor indicates that it wants an overview of the topology.
                ApplicationClient -> ApplicationFacade: interface TopologyOverview
                                                               void getTopologyOverview(int custOrgID)
            2. The system looks up the pluggable devices that are available to the customer organisation
           that owns the primary actor, and composes a view on the topology including these pluggable devices.
                ApplicationFacade -> ApplicationManager: interface Apps: List<RoomTopology> getTopology(int custOrgID)
                TopologyManager -> DeviceDB: interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID) 
            3. The system presents the topology view to the primary actor.
        
        UC26:

        
\subsection{Instantiation and allocation of functionality}
    This section describes the new components (and their responsibilities)
    which instantiate our solutions described in the section above. \\
    Unless stated otherwise, responsibilities assigned in previous decompositions are unchanged.

    \subparagraph{Component}
        Short description of its responsibilities. (Relevant QA or UC)


\subsection{Interfaces for child modules}
    This section lists new interfaces assigned to the components defined
    in the section above. Detailed information about each interface and
    its methods can be found under chapter \ref{ch:elements-datatype}. \\

    \subsubsection{Component}
        \begin{itemize}
            \item Interface
        \end{itemize}

\subsection{Data type definitions}
    This section lists the new data types introduced during this decomposition.

    \begin{itemize}
        \item DateTime: Represents an instant in time, typically expressed as a date and time of day.
    \end{itemize}
