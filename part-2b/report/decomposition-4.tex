\section{Decomposition 4: Av2, UC12, UC25, UC26, UC27 (application execution subsystem)}


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{Av2}: Application failure
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC12}: Perform actuation command \\
              Short description of the UC.
        \item \emph{UC13}: Configure pluggable device \\
              Short description of the UC.
        \item \emph{UC25}: Access topology and available devices \\
              Short description of the UC.
        \item \emph{UC24}: Consult historical data \\
              Short description of the UC.
        \item \emph{UC26}: Send application command or message to external front-end \\
              Short description of the UC.
        \item \emph{UC27}: Receive application command or message from external front-end \\
              Short description of the UC.
    \end{itemize}

    \paragraph{Rationale}
        At this point the remaining drivers were Av1, Av2, and P1,
        which all had medium priority. We chose decompositions 4, 5,
        and 6 based on the priorities of the use cases that are related to the quality attributes. \\
        The related use cases from now on are the ones that would use components
        that are going to be changed in the decomposition.


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    % Pattern: Container
    %     Define a container to provide the execution environment for a
    %     component that supports the necessary technical infrastructure
    %     to integrate components into application-specific usage scenarios,
    %     and on specific system platforms, without tightly coupling
    %     the components with the applications or platforms.
    %
    %     Use the container to initialize and provide the runtime context for the
    %     components it manages. Define operations that enable component
    %     objects to access their connections to ports of other components,
    %     as well as to access common middleware services such as persistence,
    %     event notification, transactions, replication, load balancing,
    %     and security.

    \paragraph{Av2: Detection of failures}
        The system is able to autonomously detect failures of its individual
        application execution components, failing applications, and failing application containers. \\
        Upon detection, a SIoTIP system administrator is notified. \\
        The failure of an internal application execution component is detected within 30 seconds.
        Detection of failed hardware or crashed software happens within 5 seconds.
        SIoTIP system administrators are notified within 1 minute.\\

        To detect failures, we made use of the \texttt{Container} pattern.
        The application execution subsystem is composed of:
        \begin{itemize}
            \item \texttt{ApplicationContainer}
            \item \texttt{ApplicationContainerMonitor}
            \item \texttt{ApplicationContainerManager}
            \item \texttt{ApplicationExecutionSubsystemMonitor}
        \end{itemize}

        The \texttt{ApplicationContainer}s are deployed in groups on different nodes.

        \texttt{ApplicationContainer}: is a container/sandbox that has 1 running application instance
        \texttt{ApplicationContainerMonitor}: monitors the \texttt{ApplicationContainer} instances

        To detect failing applications, \texttt{ApplicationContainer} and \texttt{ApplicationContainerMonitor}
            ApplicationContainer -> ApplicationContainerMonitor: void applicationCrashed(id applicationInstanceID)

        To detect failling application containers, \texttt{ApplicationContainerMonitor}
            ApplicationContainerMonitor -> ApplicationContainer: Echo ping()
            -> we say container has crashed/failed when the following has no response:

        To detect failures of individual application execution components,
        This means that one of \texttt{ApplicationContainer}, \texttt{ApplicationContainerMonitor}, \texttt{ApplicationContainerManager} crashed.
        If the \texttt{ApplicationContainer} failed, then the \texttt{ApplicationContainerMonitor} would detect this.
        If one of the other two components failed, the \texttt{ApplicationExecutionSubsystemMonitor} is put in place to detect this.

        These components will be deployed on the Online Service and on gateways.
        Since gateways are weaker machines than the ones on the Online Service,
        the ApplicationContainer can be confgured differently for gateways.
        The ApplicationContainers will then have stricter limits on
        resources used of the node they are working on.

        % TODO: see after the decomposition if this is useful to us
        % (usage of memory, number of served requestst and so ) and some monitoring
        % system (component), that monitors container sends regularly request to this endpoint
        % and  collect this information about aplications

        % Application executing on Online Service failed & Application executing on Gateway failed
        %     -> ApplicationInstance has failed AND ApplicationContainer is still ok
        %        so ApplicationContainer sends message "application instance X has crashed"
        %
        %
        % Container of application instance crashed
        %     -> ApplicationContainer has failed
        %     -> ApplicationContainerMonitor notices this (no reply to pings maybe)
        %     -> ApplicationContainerMonitor sends a command to the ApplicationContainerManager to restart or ...
        %
        % One of the internal application execution components crashed
        %     Application execution subsystem = ApplicationContainer + ApplicationContainerMonitor + ApplicationContainerManager

    \paragraph{Av2: Resolution of application failures and application execution component failures}
        In case of application crash, the system autonomously restarts failed applications.
        If part of an application fails, the remaining parts remain operational,
        possibly in a degraded mode (graceful degradation). \\
        After 3 failed restarts the application is suspended, and the
        application developer and customer organisation are notified within 5 minutes.\\

        In case of failure of application execution components or an application
        container, a system administrator is notified. \\
        SIoTIP system administrators are notified within 1 minute.\\

        When an application instance fails, the ApplicationContainerMonitor detects this and
        sends a command to the ApplicationContainerManager to restart the application instance.
        The ApplicationContainerMonitor keeps track of how many times the
        application instance has been restarted after a failure. After 3 failed restarts, the monitor
        send a command to the ApplicationContainerManager to suspend the application instance and send
        a notification to the application developers of the application and to the
        affected customer organisaiton. Also, to achieve graceful degradation,
        the ApplicationContainerManager notifies other parts of the application instance
        of its suspension.

        If one of the components of the application execution subsystem fails,
        a SIoTIP system administrator is notified.

    \paragraph{Av2: Failures do not impact other applications or other functionality of the system}
        This does not affect other applications that are executing on the Online
        service or SIoTIP gateway. This does not affect the availability of
        other functionality of the system, such as the dashboards. \\
        Applications fail independently: they are executed within their own
        container to avoid application crashes to affect other applications.\\

        Each ApplicationContainer contains one application instance. If an application fails,
        then this will be handled by the application execution subsystem so this
        does not affect any other application or other functionality of the system.
        The ApplicationContainers are constructed such that failures of applications
        do not affect the containers. The ApplicationContainers are to be deployed
        on different nodes alone or grouped with other containers. Write something here.


    % TODO: how do you guarantee this?
    % \paragraph{Av2: Up-time of application execution subsystem}
    %     The subsystem for executing applications in the Online Service must
    %     have a guaranteed minimal up-time. The subsystem for executing
    %     applications in the Online Service must be available
    %     99\% of the time, measured per month. \\
    %     Solution for the problem.
    %
    %     containers can have replicas, for example every container has 3 replicas and
    %     when one crash  there has to be sometnig that find out that there are
    %     just 2 replicas now and it is needed to create new replica.
    %
    %     There is also needed component for load balancing.


        UC12:
            DEVELOPERS WRITE THIS: command = "on"
            actuators = getActuatorsOfType("lightswitch")
            foreach (actuator) {
                actuator.command("on")
            }

            WE NEED TO CONVERT "on" TO A COMMAND THAT THE ACTUATOR UNDERSTANDS
            "on" => "turnOn"
            "on" => "lightOn"
            "on" => "switch"

            1. An application indicates that it wants one or more pluggable devices to perform an actuation command
                from client application:
                    ApplicationClient -> ApplicationFacade:           interface AppDeviceMgmt: void sendActuationCommand(List<PluggableDeviceID> devices, string command)
                        Effect: Sends a command for a list of actuators to ApplicationManagementLogic for construction of the actuation command messages.
                        \item Created for: UC12.1
                    ApplicationFacade -> ApplicationManagementLogic:  interface AppDeviceMgmt:  void sendActuationCommand(List<PluggableDeviceID> devices, string command)
                        Effect: Sends a command for a list of actuators to ApplicationManagementLogic for construction of the actuation command messages.
                        \item Created for:UC12.1

                from application on online service:
                    ApplicationContainer -> ApplicationManagementLogic: interface AppDeviceMgmt: void sendActuationCommand(List<PluggableDeviceID> devices, string command)
                        Effect: Sends a command for a list of actuators to ApplicationManagementLogic for construction of the actuation command messages.
                        \item Created for:UC12.1

                from application on gateway: SKIP STEP 2
                    GW/ApplicationContainer -> GW/DeviceCommandConstructor: interface Commands: void sendActuationCommand(List<PluggableDeviceID> device, string commandName)
                        Effect: Sends a command for a list of actuators to DeviceCommandConstructor on the Gateway for construction of the actuation command messages.
                        \item Exceptions: UnknownCommandException
                        \item Created for: UC12 - commands from applications on gateways
                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: Map<PluggableDeviceID, string> getFormattingSyntaxForDevices(List<PluggableDeviceID> devices)
                        Effect: Retrieves the specific formatting syntax for a list of pluggable devices from the DeviceManager.
                        \item Created for: UC12 - commands from applications on gateways
                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: void sendActuationCommand(Map<PluggableDeviceID, string> commandsForDevices)
                        Effect: Sends correctly constructed actuation commands for a group of actuators to the DeviceManager.
                        \item Created for: UC12 - commands from applications on gateways


            2. The system
                -constructs the actuation command message according to the specific formatting syntax for the involved pluggable device(s)
                    ApplicationManagementLogic -> DeviceCommandConstructor:  interface Commands:  list<string> constructCommandsForDevices(string command, List<PluggableDeviceID> devices)
                        Effect: Constructs actuation commands according to the specific formatting syntax for the given pluggable devices. The command 'command' is a command that application developers use for a group of devices.
                        \item Exceptions: UnknownCommandException
                        \item Created for: UC12.2
                    DeviceCommandConstructor -> DeviceDB: interface AppDeviceMgmt: Map<PluggableDeviceID, string> getFormattingSyntaxForDevices(List<PluggableDeviceID> devices)
                        Effect: Retrieves the specific formatting syntax for a list of pluggable devices.
                        \item Created for: UC12.2-3

                -sends the command message to the intended pluggable device(s).
                    DeviceCommandConstructor -> DeviceDB:      interface AppDeviceMgmt: Map<PluggableDeviceID, GatewayInfo> getGatewaysForDevices(List<PluggableDeviceID> devices)
                        Effect: Returns a map of PluggableDevices with the gateways they are connected to.
                        \item Created for: UC12.2
                    DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: void sendActuationCommand(List<PluggableDeviceID> actuators, List<string> commands)
                        Effect: Sends an actuation command to an actuator.
                        \item Created for: UC12.2

            3. The pluggable device(s) receive(s) the actuation command message and perform(s) the contained actuation command.
                    DeviceManager -> Mote: interface DeviceMgmt: void sendActuationCommand(PluggableDeviceID device, string commandName)
                    Effect: Sends command from GatewayFacade to Mote for the pluggable device
                        \item Created for: UC12.3
                    Mote -> PluggableDevice: interface Actuate:    void sendActuationCommand(string commandName)


        TODO step 5
        TODO MONIKA QUESTION SHE DOES NOT LIKE THIS
        UC13:
            1. The primary actor specifies that it wants to set a configuration parameter of a pluggable device.

                from client application:
                    ApplicationClient -> ApplicationFacade:           interface AppDeviceMgmt:       void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device.
                        \item Created for: UC13.1
                    ApplicationFacade -> ApplicationManagementLogic:  interface AppDeviceMgmt:  void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device.
                        \item Created for: UC13.1

                from application on online service:
                    ApplicationContainer -> ApplicationManagementLogic: interface AppDeviceMgmt: void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device.
                        \item Created for: UC13.1

                from application on gateway: SKIP STEPS 2 AND 3
                    GW/ApplicationContainer -> GW/DeviceCommandConstructor: interface Commands: void verifyAndConstructConfigurationsForDevice(PluggableDevideID pID, Map<string, string> config)
                        Effect: Verifies the configuration parameters for a pluggable device. It the parameters have been successfuly verified,
                                constructs a reconfiguration command according to the specific formatting syntax for the pluggable device and sends it to the DeviceManager if everything is correct.
                        \item Exceptions: UnkownConfigurationParameterException
                        \item Created for: UC13 - configuration commands from applications on gateways

                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: string getPossibleConfigurationParametersForDevice(PluggableDeviceID pID)
                        Effect: Retrieves the possible configuration parameters for a pluggable device.
                        \item Created for: UC13 - configuration commands from applications on gateways

                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: Map<PluggableDeviceID, string> getFormattingSyntaxForDevices(List<PluggableDeviceID> devices)
                        Effect: Retrieves the specific formatting syntax for a list of pluggable devices.
                        \item Created for: UC13 - configuration commands from applications on gateways

                    GW/DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device. The DeviceManager first determines whether the pluggable device needs to be reconfigured. To do this,
                                it checks the data it has about configurations set by other applications on the pluggable device. If the device can be reconfigured, then the configuration
                                command is propagated to the pluggable device.
                        \item Created for: UC13 - configuration commands from applications on gateways


            2. The system verifies that the value of the configuration parameter is valid for the device (for example, a sensor which provides temperature information may have hardware limits on the sampling frequency).

                    ApplicationManagementLogic -> DeviceCommandConstructor: interface Commands: void verifyAndConstructConfigurationsForDevice(PluggableDevideID pID, Map<string, string> config)
                        Effect: Verifies the configuration parameters for a pluggable device. It the parameters have been successfuly verified,
                                constructs a reconfiguration command according to the specific formatting syntax for the pluggable device and sends it to the DeviceManager if everything is correct.
                        \item Exceptions: UnkownConfigurationParameterException
                        \item Created for: UC13.2-3

                    DeviceCommandConstructor -> DeviceDB: interface AppDeviceMgmt: string getPossibleConfigurationParametersForDevice(PluggableDeviceID pID)
                        Effect: Retrieves the possible configuration parameters for a pluggable device.
                        \item Created for: UC13.2

                    DeviceCommandConstructor -> DeviceDB: interface AppDeviceMgmt: Map<PluggableDeviceID, string> getFormattingSyntaxForDevices(List<PluggableDeviceID> devices)
                        Effect: Retrieves the specific formatting syntax for a list of pluggable devices.
                        \item Created for: UC13 - commands from applications on gateways


            3. The system determines whether the pluggable device needs to be reconfigured, and if so,
               constructs a reconfiguration command according to the specific formatting syntax for the pluggable device and sends it to the pluggable device.

                    DeviceCommandConstructor -> DeviceManager: interface DeviceCommands: void setConfiguration(PluggableDevideID pID, Map<string, string> config)
                        Effect: Sets configuration parameters of a pluggable device. The DeviceManager first determines whether the pluggable device needs to be reconfigured. To do this,
                                it checks the data it has about configurations set by other applications on the pluggable device. If the device can be reconfigured, then the configuration
                                command is propagated to the pluggable device.
                        \item Created for: UC13.3

            4. The system updates the internal configuration of the pluggable device.
                    DeviceManager -> Mote: interface DeviceMgmt: void setConfig(...)

            5. The system informs the primary actor that the reconfiguration was done successfully.
                    We "forgot" this step

        UC24:
            1. The primary actor indicates that it wants to consult a specified collection of historical data in a specified timeframe.
                from client application:
                    ApplicationClient -> ApplicationFacade: interface AppDeviceMgmt: Map<PluggableDeviceID, List<DeviceData>> getDataForDevices(List<PluggableDeviceID> devices, DateTime from, DateTime to)
                        Effect: Returns DeviceData of pluggable devices over a specified time period.
                        \item Created for: UC24.1
                    ApplicationClient -> ApplicationFacade: interface AppDeviceMgmt: Map<PluggableDeviceID, List<DeviceData>> getDataForRoom(RoomTopology room, DateTime from, DateTime to)
                        Effect: Returns DeviceData of pluggable devices in a room over a specified time period.
                        \item Created for: UC24.1

                    ApplicationFacade -> ApplicationManagementLogic: interface AppDeviceMgmt: Map<PluggableDeviceID, List<DeviceData>> getDataForDevices(List<PluggableDeviceID> devices, DateTime from, DateTime to)
                        Effect: Returns DeviceData of pluggable devices over a specified time period.
                        \item Created for: UC24.1
                    ApplicationClient -> ApplicationFacade: interface AppDeviceMgmt: Map<PluggableDeviceID, List<DeviceData>> getDataForRoom(RoomTopology room, DateTime from, DateTime to)
                        Effect: Returns DeviceData of pluggable devices in a room over a specified time period.
                        \item Created for: UC24.1

                from application on online service:
                    ApplicationContainer -> ApplicationManagementLogic: interface AppDeviceMgmt: Map<PluggableDeviceID, List<DeviceData>> getDataForDevices(List<PluggableDeviceID> devices, DateTime from, DateTime to)
                        Effect: Returns DeviceData of pluggable devices over a specified time period.
                        \item Created for: UC24.1
                    ApplicationContainer -> ApplicationManagementLogic: interface AppDeviceMgmt: Map<PluggableDeviceID, List<DeviceData>> getDataForRoom(RoomTopology room, DateTime from, DateTime to)
                        Effect: Returns DeviceData of pluggable devices in a room over a specified time period.
                        \item Created for: UC24.1

                from application on gateway:
                    GW/ApplicationContainer -> DeviceDataScheduler: interface RequestData: list<DeviceData> getData(pID, from, to)

            2. The system determines from which pluggable devices the data is required and looks up the data.
                ApplicationManagementLogic parses the RoomTopology object and uses the PluggableDeviceIDs in the RoomTopology

                    ApplicationManagementLogic -> DeviceDataScheduler: interface RequestData: Map<PluggableDeviceID, List<DeviceData>> getDataForDevices(List<PluggableDeviceID> devices, DateTime from, DateTime to)
                        Effect: Returns DeviceData of pluggable devices over a specified time period.
                        \item Created for: UC24.2
                    DeviceDataScheduler -> PluggableDeviceDB: interface DeviceData: Map<PluggableDeviceID, List<DeviceData>> getDataForDevices(List<PluggableDeviceID> devices, DateTime from, DateTime to)
                        Effect: Returns DeviceData of pluggable devices over a specified time period.
                        \item Created for: UC24.2

            3. The system presents the primary actor with the requested historical overview, e.g. as a table.
                Return value of first call.


        UC25:
            1. The primary actor indicates that it wants an overview of the topology.
                applicationClient wants overview:
                    ApplicationClient -> ApplicationFacade: interface AppMgmt: List<RoomTopology> getTopologyOverview(int applicationInstanceID, int customerOrganisationID)
                        Effect: Returns a list of RoomTopology containing devices that an ApplicationInstance has access to.
                        \item Created for: UC25.1
                    ApplicationFacade -> ApplicationManagementLogic: interface FrontEndAppRequests: List<RoomTopology> getTopologyOverview(int applicationInstanceID, int customerOrganisationID)
                        Effect: Returns a list of RoomTopology containing devices that an ApplicationInstance has access to.
                        \item Created for: UC25.1

                applicationContainer wants overview:
                    ApplicationContainer -> ApplicationContainerManager: interface X: List<RoomTopology> getTopologyOverview(int applicationInstanceID, int customerOrganisationID)
                        Effect: Returns a list of RoomTopology containing devices that an ApplicationInstance has access to.
                        \item Created for: UC25.1
                    ApplicationContainerManager -> ApplicationManagementLogic: interface X: List<RoomTopology> getTopologyOverview(int applicationInstanceID, int customerOrganisationID)
                        Effect: Returns a list of RoomTopology containing devices that an ApplicationInstance has access to.
                        \item Created for: UC25.1

            2. The system looks up the pluggable devices that are available to the customer organisation that owns the primary actor,
               and composes a view on the topology including these pluggable devices.
                    ApplicationManagementLogic -> TopologyManager: interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID)
                    TopologyManager -> DeviceDB: interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID)

                    ApplicationManagementLogic -> OtherDataDB: interface AppMgmt: List<PluggableDeviceID> getDevicesForApplication(int applicationInstanceID)

            3. The system presents the topology view to the primary actor.
                    = return value of getTopologyOverview

        UC26:
            AppDevelopers want to send a message to:
                Gateway:   sendMessageToGateway(string message)
                OS:        sendMessageToOnlineService(string message)
                AppClient: sendMessageToExternalClient(string message, IPAddress host, int port)

           Some deployment rationale: ApplicationManagementLogic <--- HTTP ---> ApplicationClient
                                      ApplicationManagementLogic <---      ---> GW/ApplicationContainer

           TODO: somewhere we need to store on which gateways ApplicationContainers are running.
                ApplicationManagementLogic -> OtherDataDB: void createApplicationInstance(int applicationInstance, IPAddress gatewayIPAddress)
                    Effect: Stores on which gateway an ApplicationInstance is running.
                    \item Created for: TODO

           Alternative 3b. NotAllowedException

            1. The primary actor indicates it wants to send an application command or message to an external
               front-end and specifies the destination (e.g., as an application identifier for SIoTIP applications,
               or a hostname and port for external systems).

                FROM APP INSTANCE TO FRONT END:
                     ApplicationContainer -> ApplicationContainerManager: interface AppRequests: void sendMessageToExternalFrontEnd(string hostName, int port, string message)
                        Effect: Sends a message from an ApplicationInstance to an external front end. The ApplicationInstance provides the hostname and port.
                        \item Created for: UC26.1
                     ApplicationContainerManager -> ApplicationManagementLogic: interface AppRequests: void sendMessageToExternalFrontEnd(string hostName, int port, string message)
                         Effect: Sends a message from an ApplicationInstance to an external front end. The ApplicationInstance provides the hostname and port.
                         \item Created for: UC26.1

                FROM APP INSTANCE TO APP INSTANCE:
                     ApplicationContainer -> ApplicationContainerManager: interface AppRequests: void sendCommandToApplicationInstance(int applicationInstanceID, string command)
                        Effect: Sends a command from an ApplicationInstance to another part of the same application that is running on another location in the system.
                        \item Created for: UC26.1
                     ApplicationContainerManager -> ApplicationManagementLogic: interface AppRequests: void sendCommandToApplicationInstance(int applicationInstanceID, string command)
                         Effect: Sends a command from an ApplicationInstance to another part of the same application that is running on another location in the system.
                         \item Created for: UC26.1

                FROM FRONT END TO APP INSTANCE:
                    ApplicationClient -> ApplicationFacade: interface AppMgmt: void sendCommandToApplicationInstance(int applicationInstanceID, string command)
                        Effect: Sends a command from an external front-end to an ApplicationInstance.
                        \item Created for: UC26.1
                    ApplicationFacade -> ApplicationManagementLogic: interface AppMgmt: void sendCommandToApplicationInstance(int applicationInstanceID, string command)
                        Effect: Sends a command from an external front-end to an ApplicationInstance.
                        \item Created for: UC26.1

            2. The system checks that the primary actor is allowed to send to the specified destination.
                    THE MESSAGE HAS ARRIVED IN ApplicationManagementLogic

                    Don't need to check, since an application can only send commands to another part of the same application.
                    If the command comes from a gateway -> send it to the online service instance
                    If the command comes from the online service -> send it to the gateway instance
                    If the command is for an external front end -> just send the message to the hostname and port

                    Maybe a check can be done here to do some kind of rate limiting, if developers want to send
                    more requests, they pay more \$\$\$

            3. If the primary actor is allowed to send to the destination, and if the destination is another application,
               the system delivers the application command to that destination
                    (Include: UC27: Receive application command or message from external front-end).

            4. The system informs the primary actor that the message was sent.
                    We "forgot" this step

        UC27:
            Comment from professor:
               UC27 (just as UC26) deals with communication between different parts of the same application (including messages coming from front-ends).

            1. The system receives an application command or message for a SIoTIP application.
                ApplicationManagementLogic has received an application command (SEE UC26)

            2. The system checks that the destination is available.
                message is for Gateway/ApplicationContainer:
                    Destination = GW/ApplicationContainer
                    find where the application container is, -> OtherDataDB: gatewayOfApplicationContainer
                    then send it to the correct GW/ApplicationContainerManager
                    the applicationContainerMAnager will send the message to the correct ApplicationContainer
                    ApplicationContainerManagers keep track of ApplicationContainer IDs

                    ApplicationManagementLogic -> OtherDataDB: interface AppMgmt: Gateway getGatewayForApplicationInstance(int applicationInstanceID)
                        Effect: Returns information about a gateway for a certain application instance running on a gateway. Returns null if there is no application instance with the given id running on any gateway.
                        \item Created for: UC27.2

                    ApplicationManagementLogic -> GW/ApplicationContainerManager: interface AppInstanceManagement: boolean isApplicationInstanceAvailable(int applicationInstanceID)
                        Effect: Returns true if a certain ApplicationInstance is available.
                        \item Created for: UC27.2

                    GW/ApplicationContainerManager -> GW/ApplicationContainerMonitor: interface Monitoring: boolean isApplicationInstanceAvailable(int applicationInstanceID)
                        Effect: Returns true if a certain ApplicationInstance is available.
                        \item Created for: UC27.2


                message is for ApplicationContainer:
                    The same, but on Online Service, so you don't need to search for the gateway
                    just send the message to the OS ApplicationContainerManager, it will do the rest

                    ApplicationManagementLogic -> ApplicationContainerManager: interface AppInstanceManagement: boolean isApplicationInstanceAvailable(int applicationInstanceID)
                        Effect: Returns true if a certain ApplicationInstance is available.
                        \item Created for: UC27.2

                    ApplicationContainerManager -> ApplicationContainerMonitor: interface Monitoring: boolean isApplicationInstanceAvailable(int applicationInstanceID)
                        Effect: Returns true if a certain ApplicationInstance is available.
                        \item Created for: UC27.2


                message is for ApplicationClient:
                    just PING the hostname and port, if the ping succeeds, send the message
                        ApplicationManagementLogic -> ExternalFrontEndClient: ping the (host, port) and check reply

            3. If the destination is available, the system delivers the message to the destination application.
                message = string

                message is for Gateway/ApplicationContainer:
                    ApplicationManagementLogic -> GW/ApplicationContainerManager: interface AppInstanceManagement: void sendMessageToApplicationInstance(int applicationInstanceID, string message)
                        Effect: Sends a message or command to an ApplicationInstance from the ApplicationInstance on a different location or from an external front end.
                        \item Created for UC26, UC27
                    GW/ApplicationContainerManager -> GW/ApplicationContainer: interface AppInstanceManagement: void sendMessageToApplicationInstance(int applicationInstanceID, string message)
                        Effect: Sends a message or command to an ApplicationInstance from the ApplicationInstance on a different location or from an external front end.
                        \item Created for UC26, UC27

                message is for ApplicationContainer:
                    ApplicationManagementLogic -> ApplicationContainerManager: interface AppInstanceManagement: void sendMessageToApplicationInstance(int applicationInstanceID, string message)
                        Effect: Sends a message or command to an ApplicationInstance from the ApplicationInstance on a different location or from an external front end.
                        \item Created for UC26, UC27
                    ApplicationContainerManager -> ApplicationContainer: interface AppInstanceManagement: void sendMessageToApplicationInstance(int applicationInstanceID, string message)
                        Effect: Sends a message or command to an ApplicationInstance from the ApplicationInstance on a different location or from an external front end.
                        \item Created for UC26, UC27

                message is for ApplicationClient:
                    ApplicationManagementLogic -> ExternalFrontEndClient: Open socket (host and port are given) -> send message -> close socket

\subsection{Instantiation and allocation of functionality}
    This section lists the new components which instantiate our solutions
    described in the section above. For each component we note the quality
    attribute or use case that prompted us to create it. Descriptions about
    the components can be found under chapter \ref{ch:elements-datatypes}. \\

    \begin{itemize}
        \item Component: ApplicationClient
        \item Component: ApplicationFacade
        \item Component: DeviceCommandConstructor
        \item Component: ApplicationContainer
        \item Component: ApplicationContainerManager
        \item Component: ApplicationContainerMonitor
        \item Component: DeviceCommandConstructor
        \item Component: ApplicationManagementLogic
        \item Component: ApplicationExecutionSubsystemMonitor
    \end{itemize}


\subsection{Interfaces for child modules}
    This section lists new interfaces assigned to the components defined
    in the section above. Detailed information about each interface and
    its methods can be found under chapter \ref{ch:elements-datatypes}. \\

    \subsubsection{DeviceCommandConstructor}
        \begin{itemize}
            \item Commands
        \end{itemize}

   \subsubsection{ApplicationContainer}
        \begin{itemize}
            \item AppInstanceMgmt
            \item AppMonitoring
        \end{itemize}

    \subsubsection{ApplicationContainerManager}
        \begin{itemize}
            \item AppInstanceMgmt
            \item Monitoring
            \item AppInstanceMessages
        \end{itemize}
    
    \subsubsection{ApplicationManagementLogic}
        \begin{itemize}
            \item FrontEndAppRequests
            \item AppDeviceManagement
            \item AppMgmt
            \item AppInstanceMessages
        \end{itemize}


    \subsubsection{ApplicationFacade}
        \begin{itemize}
            \item AppData
            \item AppDeviceMgmt
            \item TopologyOverview
        \end{itemize}


\subsection{Data type definitions}
    This section lists the new data types introduced during this decomposition.

    \begin{itemize}
        \item Parameter: Parameter of application e.g. usage of memory, handle requests...
    \end{itemize}
