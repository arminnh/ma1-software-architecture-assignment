\section{Decomposition 4: Av2, UC12, UC25, UC26, UC27 (application execution subsystem)}


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{Av2}: Application failure
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC12}: Perform actuation command \\
              Short description of the UC.
        \item \emph{UC13}: Configure pluggable device \\
              Short description of the UC.
        \item \emph{UC25}: Access topology and available devices \\
              Short description of the UC.
        \item \emph{UC24}: Consult historical data \\
              Short description of the UC.
        \item \emph{UC26}: Send application command or message to external front-end \\
              Short description of the UC.
        \item \emph{UC27}: Receive application command or message from external front-end \\
              Short description of the UC.
    \end{itemize}

    \paragraph{Rationale}
        At this point the remaining drivers were Av1, Av2, and P1,
        which all had medium priority. We chose decompositions 4, 5,
        and 6 based on the priorities of the use cases that are related to the quality attributes. \\
        The related use cases from now on are the ones that would use components
        that are going to be changed in the decomposition.


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    Pattern: Container
    Define a container to provide the execution environment for a
    component that supports the necessary technical infrastructure
    to integrate components into application-specific usage scenarios,
    and on specific system platforms, without tightly coupling
    the components with the applications or platforms.

    Use the container to initialize and provide the runtime context for the
components it manages. Define operations that enable component
objects to access their connections to ports of other components,
as well as to access common middleware services such as persistence,
event notification, transactions, replication, load balancing,
and security.



    \paragraph{Av2: Detection of failures}
        The system is able to autonomously detect failures of its individual
        application execution components, failing applications, and failing application containers. \\
        Upon detection, a SIoTIP system administrator is notified. \\
        The failure of an internal application execution component is detected within 30 seconds.
        Detection of failed hardware or crashed software happens within 5 seconds.
        SIoTIP system administrators are notified within 1 minute.\\

        *) APPLICATION CRASH
        -> Monitor

        ApplicationManager: that does management of instances and communication with other components

        ApplicationInstanceContainer: is a container/sandbox that has
        1 running application instance
        = application execution component
        ?? run on different hardware maybe?

        ContainerMonitor: that monitors the ContainerInstance instances

        ContainerMonitor -> ApplicationInstance: boolean check()
        ApplicationInstance -> ContainerMonitor: void applicationCrashed(id applicationInstanceID)

        *) OR APPLICATION EXECUTION COMPONENT CRASH
        -> we say container has crashed/failed when the following has no response:
        ContainerMonitor -> ApplicationInstance: boolean check()
        is ok????

        *) Detection of failed hardware
        TODO ask what hardware?? separate hardware that runs application instances?

        *) Send notification

    \paragraph{Av2: Resolution of application failures}
        In case of application crash, the system autonomously restarts failed applications.
        If part of an application fails, the remaining parts remain operational,
        possibly in a degraded mode (graceful degradation). \\
        After 3 failed restarts the application is suspended, and the
        application developer and customer organisation are notified within 5 minutes.\\
        Application fails -> ContainerMonitor detects this -> ApplicationInstance: restart
        3 failed restarts -> suspend app and send notification

        *) Graceful degradation:
        -> send message to other parts to notify of failed part
        we ca have component responsible for controlling state of application
        and can start, stop or restart application.



    \paragraph{Av2: Resolution of application execution component failures}
        In case of failure of application execution components or an application
        container, a system administrator is notified. \\
        SIoTIP system administrators are notified within 1 minute.\\
        Solution for the problem.
        ApplicationInstance failure -> send notification to system administrator
        SIoTIP system administrators are notified within 1 minute.
        application return diferent metrics

        (usage of memory, number of served requestst and so ) and some monitoring
        system (component), that monitors container sends regularly request to this endpoint
        and  collect this information about aplications

    \paragraph{Av2: Failures do not impact other applications or other functionality of the system}
        This does not affect other applications that are executing on the Online
        service or SIoTIP gateway. This does not affect the availability of
        other functionality of the system, such as the dashboards. \\
        Applications fail independently: they are executed within their own
        container to avoid application crashes to affect other applications.\\
       -> we already have this, the ApplicationContainer component.

    \paragraph{Av2: Up-time of application execution subsystem}
        The subsystem for executing applications in the Online Service must
        have a guaranteed minimal up-time. The subsystem for executing
        applications in the Online Service must be available
        99\% of the time, measured per month. \\
        Solution for the problem.
        Subsystem = ApplicationManager + ApplicationContainer + new components ???

        containers can have replicas, for example every container has 3 replicas and
        when one crash  there has to be sometnig that find out that there are
        just 2 replicas now and it is needed to create new replica.

        There is also needed component for load balancing.


        DEVELOPERS WRITE THIS: command = "on"
        actuators = getActuatorsOfType("lightswitch")
        foreach (actuator) {
            actuator.command("on")
        }

        WE NEED TO CONVERT "on" TO A COMMAND THAT THE ACTUATOR UNDERSTANDS
        "on" => "turnOn"
        "on" => "lightOn"
        "on" => "switch"

        UC12:
            1. An application indicates that it wants one or more pluggable devices to perform an actuation command
                from client application:
                    ApplicationClient -> ApplicationFacade:           interface AppMgmt:   sendCommand(List<PluggableDeviceID> devices, string command)
                        Effect: Sends command from application to the pluggable device.
                        \item Created for: UC12.1
                    ApplicationFacade -> ActuationCommandConstructor: interface Actuation: sendCommand(List<PluggableDeviceID> devices, string command)
                        Effect: Sends command from application to the pluggable device.
                        \item Created for:UC12.1

                from application on online service:
                    ApplicationContainer -> ApplicationContainerManager: interface AppRequests

                from application on gateway:

            2. The system
                -constructs the actuation command message according to the specific formatting syntax for the involved pluggable device(s)
                    ActuationCommandConstructor/ApplicationManager -> ApplicationManager: interface X:
                      void sendCommand(PluggableDeviceID device, int moteID, Map<Pluggable,String> data)
                        Effect: Sends command from application to pluggable device.
                        \item Created for: UC12.2
                    Json message createData(PluggableDeviceID device, int moteID, Map<String,String> data)
                        Effect: Constructs actuation command message for involved pluggable device(s)
                        \item Created for: UC12.2
                   

                -sends the command message to the intended pluggable device(s).
                    ApplicationManager -> GatewayFacade: interface AppDeviceMgmt:
                                          void sendActuationCommand(List<PluggableDeviceID> actuators, List<string> commands)
                         Effect: Sends command to the pluggable device
                        \item Created for: UC12.2
                   


            3. The pluggable device(s) receive(s) the actuation command message and perform(s) the contained actuation command.
                    GatewayFacade -> MoteFacade:         interface DeviceMgmt: void sendActuationCommand(PluggableDeviceID device, string commandName)
                    Effect: Sends command from GatewayFacade to Mote for the pluggable device
                        \item Created for: UC12.2
                    MoteFacade -> PluggableDeviceFacade: interface Actuate:    void sendActuationCommand(string commandName)


            Find the gateway to send the commands  to:
                ApplicationManager -> OtherDataDB: interface AppMgmt: IPAddress getDeviceGateway(PluggableDeviceID device)
                    Effect: Returns the IP address of the gateway that a pluggable device is connected to
                    \item Created for: UC12 Remarks


        UC13:
            1. The primary actor specifies that it wants to set a configuration parameter of a pluggable
            device.
                ApplicationClient -> ApplicationFacade: interface AppMgmt:
                                                        void setConfiguration(PluggableDevideID id, Map<String,String> parameters)
                ApplicationFacade -> ApplicationManager: interface DeviceMgmt:
                                                        void setConfiguration(PluggableDevideID id, Map<String,String> parameters)


            2. The system verifies that the value of the configuration parameter is valid for the device (for
               example, a sensor which provides temperature information may have hardware limits on the
               sampling frequency).
               ApplicationManager -> DeviceDB: interface AppDeviceMgmt: bool checkDeviceParameter(PluggableDeviceID):

            3. The system determines whether the pluggable device needs to be reconfigured, and if so,
               constructs a reconfiguration command according to the specific formatting syntax for the
               pluggable device and sends it to the pluggable device. ????how

            4. The system updates the internal configuration of the pluggable device.
                ApplicationManager -> Datatase: interface AppMgmt:
                                                     void setConfiguration(PluggableDeviceID id, Map<String,String> parameters)

            5. The system informs the primary actor that the reconfiguration was done successfully.
                ApplicationManager -> NotificationManager: interface Notify: notify(int userID, string message)

            Alternative scenarios:
            2a. If the value is invalid for the pluggable device, the system informs the application via an
                exception. The use case ends.
                - first exception
            Remarks:
                Note that different applications may have different preferences for a single pluggable device

        UC24:
            1. The primary actor indicates that it wants to consult a specified collection of historical data in
                a specified timeframe.
                ApplicationClient -> ApplicationFacade: interface AppData:
                                                void getHistoricalData(DateTime from, DateTime to, int custOrgID)
                ApplicationFacade -> ApplicationManager: interface Apps:
                                                void getHistoricalData(DateTime from, DateTime to, int custOrgID)
            2. The system determines from which pluggable devices the data is required and looks up the data.
                 ????
            3. The system presents the primary actor with the requested historical overview, e.g. as a table.
                ApplicationManager -> DeviceDataScheduler: interface RequestData:
                                      HistoricalData getHistoricalData(List<PluggableDeviceID> id,DateTime from, DateTime to)
                DeviceDataScheduler -> PluggableDeviceDB: interface DeviceData:
                                      HistoricalData getHistoricalData(List<PluggableDeviceID> id,DateTime from, DateTime to)

        UC25:
            1. The primary actor indicates that it wants an overview of the topology.
                ApplicationClient -> ApplicationFacade: interface TopologyOverview
                                                               void getTopologyOverview(int custOrgID)
            2. The system looks up the pluggable devices that are available to the customer organisation
           that owns the primary actor, and composes a view on the topology including these pluggable devices.
                ApplicationFacade -> ApplicationManager: interface Apps: List<RoomTopology> getTopology(int custOrgID)
                TopologyManager -> DeviceDB: interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID)
            3. The system presents the topology view to the primary actor.

        UC26:
            1. The primary actor indicates it wants to send an application command or message to an external
                front-end and specifies the destination (e.g., as an application identifier for SIoTIP applications,
                or a hostname and port for external systems).
                Map<String,String> destination = type of destination, value
                Map<String,String> requestType = Message/Command, value
                GWApplicationContainer -> GWApplicationContainerManager: interface AppRequests:
                                                   void sendRequest(Map<String,String> destination, Map<String,String> requestType)
                       Effect: Command or message is sent to  to an external front-end
                       \item Created for: UC26.1
                GWApplicationContainerManager -> GWActuationCommandConstructor: interface AppRequests:
                                                      void sendRequest(Map<String,String> destination, Map<String,String> requestType)
                         Effect: Command or message is sent to  to an external front-end
                       \item Created for: UC26.1         
            2. The system checks that the primary actor is allowed to send to the specified destination.
            AccesRightManager???
            3. If the primary actor is allowed to send to the destination, and if the destination is another
                application, the system delivers the application command to that destination (Include: UC27:
                Receive application command or message from external front-end).
                TODO: add containers and monitor to gatewayfacade
                GWActuationCommandConstructor -> ActuationCommandConstructor: interaface Actuation
                                        void sendRequest(Map<String,String> destination,Map<String,String> requestType)
                See UC27
            4. The system informs the primary actor that the message was sent.
       
       UC27:     
        1. The system receives an application command or message for a SIoTIP application.
            ActuationCommandConstructor -> ApplicationContainerManager: interface AppRequests:
                                                 void rcvApplicationRequest(Map<String,String> destination,Map<String,String> requestType)
                   Effect: ApplicationContainerManager receives message or application command
                   \item Created for: UC27.1
            
        2. The system checks that the destination is available.
            ApplicationContainerManager -> ApplicationContainerMonitor: interface Availability: 
                                                bool checkDestination(Map<String,String>  destination)
                   Effect: Return true if destionation is available
                   \item Created for: UC27.2
                   
            ApplicationContainerMonitor -> ApplicationContainer: interface AppInstanceMgmt: 
            Map<Parameters,String> checkApplicationAvailability(AppInstanceID id)
                    Effect: Return parameters and their values of application
                   \item Created for: UC27.2
            
        3. If the destination is available, the system delivers the message to the destination application.
            ApplicationContainerManager -> ApplicationContainer: interface AppRequests
                               void rcvApplicationRequest(Map<String,String> destination,Map<String,String> requestType)
                   Effect: Receive message or application command
                   \item Created for: UC27.3

\subsection{Instantiation and allocation of functionality}
    This section lists the new components which instantiate our solutions
    described in the section above. For each component we note the quality
    attribute or use case that prompted us to create it. Descriptions about
    the components can be found under chapter \ref{ch:elements-datatypes}. \\

    \begin{itemize}
        \item Component: ApplicationClient
        \item Component: ApplicationFacade
        \item Component: ActuationCommandConstructor
        \item Component: ApplicationContainer
        \item Component: ApplicationContainerManager
        \item Component: ApplicationContainerMonitor
        \item Component: GWActuationCommandConstructor
        \item Component: GWApplicationContainer
        \item Component: GWApplicationContainerManager
        \item Component: GWApplicationContainerMonitor
    \end{itemize}


\subsection{Interfaces for child modules}
    This section lists new interfaces assigned to the components defined
    in the section above. Detailed information about each interface and
    its methods can be found under chapter \ref{ch:elements-datatypes}. \\

    \subsubsection{ActuationCommandConstructor}
        \begin{itemize}
            \item Actuation
        \end{itemize}
    \subsubsection{GWActuationCommandConstructor}
        \begin{itemize}
            \item AppRequests
        \end{itemize}
   \subsubsection{ApplicationContainer}
        \begin{itemize}
            \item AppRequests
        \end{itemize}
    \subsubsection{ApplicationContainerManager}
        \begin{itemize}
            \item AppRequests
        \end{itemize}
    \subsubsection{GWApplicationContainerManager}
        \begin{itemize}
            \item AppRequests
        \end{itemize}
    \subsubsection{ApplicationFacade}
        \begin{itemize}
            \item AppMgmt
        \end{itemize}
    \subsubsection{ApplicationFacade}
        \begin{itemize}
            \item DeviceMgmt
        \end{itemize}
    \subsubsection{ApplicationFacade}
        \begin{itemize}
            \item TopologyOverview
        \end{itemize}
    \subsubsection{PluggableDeviceFacade}
        \begin{itemize}
            \item Actuate
        \end{itemize}

\subsection{Data type definitions}
    This section lists the new data types introduced during this decomposition.

    \begin{itemize}
        \item Parameter: Parameter of application e.g. usage of memory, handle requests...
    \end{itemize}
