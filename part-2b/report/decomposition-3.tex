\section{Decomposition 3: U2, UC4, UC6, UC9, UC10, UC17, UC19.7-11}

\subsection{Elements/Subsystem to decompose/expand}
    In this run we decompose/expand ...


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{U2}: Easy installation
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC4}: Install mote \\
              Short description
        \item \emph{UC6}: Insert a pluggable device into a mote \\
              Short description
        \item \emph{UC9}: Configure pluggable device access rights \\
              Short description
        \item \emph{UC10}: Consult and configure topology \\
              Short description
        \item \emph{UC17}: Activate an application \\
              Short description
        \item \emph{UC19}: Subscribe to application \\
              Short description
    \end{itemize}


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    Some dabatase tables text we wrote:
        pluggable\_devices
        topology\_pluggable\_devices
        permissions\_pluggable\_devices

        topology
            gateways(id, floor, room\_number, wall, status)
            motes(id, gateway\_id, floor, room\_number, status)
            pluggable\_devices(id, mote\_id, gateway\_id, status, physical location)
            % pluggable\_devices\_redundancies(deviceID1, deviceID2)
            pluggable\_devices\_relationships(deviceID1, deviceID2, type)

            Relationship
                PluggableDeviceID device1
                PluggableDeviceID device2
                string type

                Relationship(fireDetector, smokeDetector, "redundancy")
                Relationship(fireDetector, smokeDetector, "\>")

            RoomTopology:
                int roomID
                List<DeviceInfo> devices
                List<Relationship> devices_relationships

        access rights
            rights(id, origranisation\_id, device\_id, can\_read, can\_configure, can\_send\_actuation\_command)

    \paragraph{U2: Gateway installation}
        The gateway should not require any configuration, other than being connected
        to the local wired or WiFi network, after it is plugged into an electrical
        socket. An infrastructure owner should be able get the SIoTIP gateway
        up-and-running (connected) within 10 minutes given that the information
        (e.g. WiFi SSID and passphrase) is available to the person responsible for
        the installation. \\

        A connection to the internet is a constraint of the GatewayFacade.
        After the gateway is connected to the internet (we don't model this),
        it connects to the gateway (we don't model this?) and registers itself (we model this). \\
        When an infrastructure owner orders a gateway, that gateway is linked to the IO.
        Gateway was already in the DeviceDB, but it was not linked to anyone. It has a gatewayID.
        Important info related to gateways: GatewayID (new class), infrastructureOwnerID, IPAddress, status (active/inactive), location (in topology table)
        gateway registers with online service:
            sets status to 'active' and updates IPAddress if different

            GatewayFacade -> DeviceDB: interface DeviceMgmt: registerGateway(GatewayID id, IPAddress address)


    \paragraph{U2: Mote installation}
        Installing a new mote should not require more configuration than adding it
        to the topology. Adding new motes, sensors or actuators should not involve
        more than just starting motes, and plugging devices into motes â€“ plug-and-play!
        Reintroducing a previously known mote, with the same pluggable devices attached to it,
        should not require any configuration. It is automatically re-added on
        its last known location on the topology. The attached pluggable devices
        are automatically initialised and configured with their last known
        configuration and access rights. \\
        Thing that need to happen automatically:
        *) mote should find the gateway (mote sends a broadcast message->ReceiveBroadcast) => this is done automatically? see remarks of the use case
        *) gateway should register the mote (DeviceManager update, store entry in DB)
        *) on reintroduction of motes: DeviceManager notices this, makes the gateway send a message to online service to reuse some old topology

        UC4:
            Remark : The mote is pre-congured to connect to a specic gateway by
             the hardware manufacturer. This linking process is out of scope for
             this assignment. Likewise, the automatic assignment of an IPv6 address
             to the mote is out of scope.

            if new mote:
                for step 2., we can use the heartbeat system. heartbeat is sent from mote to gateway,
                the DeviceManager in the gateway notices that this is from a new mote and starts
                the registerMote procedure
                FOR RATIONALE: The IPAddress of the mote can be parsed out of the 6lowpan header in the heartbeat messages
                ALTERNATIVE IS GatewayFacade: registerMote, but this is more work (battery power and implementation)

                FOR RATIONALE: be careful with int moteID. when we register, we send MoteInfo to the DB, DB returns a DIFFERENT int moteID
                               we use the other moteID in the rest of the system
                % DONT NEED THIS ONE 2. MoteFacade -> GatewayFacade: registerMote(moteID, IPAddress moteIPAddress)
                % ALSO DONT NEED THIS ONE 3. GatewayFacade -> DeviceManager: registerMote(moteID, IPAddress moteIPAddress)
                % 3. DeviceManager -> GatewayFacade -> DeviceDB: int moteID addMote(moteID, gatewayID, IPAddress moteIPAddress)
                                                %   -> TopologyManager: addMote(infrastructureOwnerID, gatewayID, moteID) // status = unplaced
                                                    %  TopologyManager -> DeviceDB: addMoteInTopology(infrastructureOwnerID, gatewayID, moteID)
                % 4. DeviceManager -> GatewayFacade -> NotificationHandler: notify(infrastructureOwnerID, message)

        if reintroduced mote:
            It is automatically re-added on its last known location on the topology.
                % 3. DeviceManager -> GatewayFacade -> DeviceDB: reactivateMote(moteID)
                % 3. DeviceManager -> GatewayFacade -> TopologyManager: reactivateMote(moteID) // status = placed, location is still there from the past, it was not removed

            The attached pluggable devices are automatically initialised and configured with their last known configuration.
            The attached pluggable devices are automatically initialised and configured with their last known access rights.
                Already done by DeviceManager, it detects the devices, updates DB, and configures the devices
                % 3. DeviceManager -> GatewayFacade -> DeviceDB: reactivateDevice(deviceID)


    \paragraph{U2: Pluggable device installation}
        Adding new sensors or actuators should require no further customer
        actions besides plugging it into the mote. Configurable sensors and
        actuators should have a working default configuration.
        Pluggable devices added to an already known mote are automatically
        added in the right location on the topology.
        Making (initialised) sensors and actuators available to customer
        organisations and applications should not require more effort than
        configuring access rights (cf. UC9). \\
        *) After devices are plugged in: connect to mote, set up default configurations
        *) if the mote is already known, the device is added to the right location on the topology
        *) need something for configuration of access rights, can only happen for initialised devices

        *) for reactivating last configurations: just set status to active and don't change configuration field, it will still be the same as in the past
            alternative: current\_configuration and last\_configuration in DB
            alternative: store all configurations on Gateway -> but it has bad resources
            alternative: store all versions on DeviceDB -> but lots of useless data then = extra work for db

        *) Pluggable devices added to an already known mote are automatically added in "the right location" on the topology.
            what exactly is a location?
            => when a pluggable device is connected to a new mote, the pluggable device gets the location of the mote by default

        UC6: insert a pluggable device into a mote
            mote is already installed

            when device is plugged into a mote:
                2. The system receives a message from the mote, informing it of the new pluggable device. This
                message species the identier and type of the new pluggable device.
                => for registration, we can use the heartbeat system. heartbeat is sent from mote to gateway,
                the DeviceManager in the gateway notices that there is a new pluggable device

                Status of new pluggable devices will be 'uninitialised' by default in the DB, and 'unplaced' in topology
                New pluggable devices get the location of the mote in the topology, but have status unplaced

                % DONT NEED THIS mote -> DeviceManager: registerDevice(id, type) (registers device as uninitialised)
                % DeviceManager -> PluggableDeviceDatabase -> DeviceDB: addDevice(PluggableDeviceID id, PluggableDeviceType type, Map<String, String> defaultConfigurations)
                % DeviceManager -> TopologyManager -> DeviceDB: addDevice(PluggableDeviceID id, int moteID)
                % DeviceManager -> GatewayFacade: newPluggableDevice(PluggableDeviceID id, PluggableDeviceType type, Map<String, String> defaultConfigurations)

                % In these methods, if the device already exists and is plugged in in another mote, clear the data

                % For default configurations: when it is a new device, we assume that the defaults are turned on by default so we don't have to do anything here

            if the device is a known previously active device (ON THE SAME MOTE):
                % DONT NEED THIS mote -> DeviceManager: registerDevice(id, type)

                âˆ— marks the pluggable device as â€˜activeâ€™:
                    % DeviceManager -> DeviceDB: reactivateDevice(PluggableDeviceID id)

                âˆ— updates the topology:
                    % DeviceManager -> TopologyManager: reactivateDevice(PluggableDeviceID id)

                âˆ— configures the pluggable device with the last known access rights:
                    % DeviceManager -> AccessRightsManager: reactivate(deviceID)
                    RATIONALE: nothing needs to happen here, permission information will just not be used if the device is inactive
                               if the device is reactivated, the permissions are already there

                * configures the pluggable device with the last known configuration:
                    % DeviceManager -> GatewayFacade -> DeviceDB: interface DeviceMgmt: Map<String, String> getConfig(PluggableDeviceID id)
                    % DeviceManager -> MoteFacade -> PluggableDeviceFacade: setConfig(config)

                âˆ— checks and activates applications which can now execute again:
                    RATIONALE: gateway sends id of IO instead of fetching customers of IO. the online service will do that extra work = less work for gateway.
                    % DeviceManager -> GatewayFacade -> ApplicationManager: checkApplicationsForActivationForInfrastructureOwner(int infrastructureOwnerID)

                * send notification
                    % DeviceManager -> NotificationHandler: reactivatedPluggableDevice

        UC9: configure pluggable device access rights
            Map<int, AccessRights> : maps customerOrganisationIDs to their AccessRights

            1. The primary actor indicates that they want to configure the access rights to pluggable devices.
                % InfrastructureOwnerClient -> InfrastructureOwnerFacade - interface AccessRights: List<DeviceInfo> getAccessRights(int infrastructureOwnerID)

            2. The system retrieves the list of pluggable devices associated with the primary actor and presents these to the primary actor.
                % InfrastructureOwnerFacade -> InfrastructureOwnerManager: interface IOMgmt:     List<DeviceInfo>  getDevices(int infrastructureOwnerID)
                % InfrastructureOwnerManager -> DeviceDB:                  interface DeviceMgmt: List<DeviceInfo>  getDevices(int infrastructureOwnerID)
                % presents these to the primary actor = return of getAccessRights(int infrastructureOwnerID)

            3. The primary actor indicates for which pluggable device they want to configure the access rights.
                % InfrastructureOwnerClient -> InfrastructureOwnerFacade: interface AccessRights: Map<int, AccessRights> configureDevice(PluggableDeviceID id)

            4. The system retrieves all customer organisations associated with the primary actor and presents these to the primary actor,
               thereby indicating which of these customer organizations already have access to the pluggable device.
                % InfrastructureOwnerFacade -> InfrastructureOwnerManager: interface IOMgmt:           List<int> getCustomerOrganisations(int infrastructureOwnerID)
                % InfrastructureOwnerManager -> Database:                  interface IOMgmt:           List<int> getCustomerOrganisations(int infrastructureOwnerID)
                % InfrastructureOwnerFacade -> AccessRightsManager:        interface AccessRightsMgmt: Map<int, AccessRights> getCustomerOrganisationsRights(PluggableDeviceID id, List<int> custOrgIDs)
                % AccessRightsManager -> DeviceDB:                         interface DeviceMgmt:       Map<int, AccessRights> getCustomerOrganisationsRights(PluggableDeviceID id, List<int> custOrgIDs)

            5. The system asks to indicate which of these should have access to the pluggable device.
                % = is return value of configureDevice(PluggableDeviceID id)

            6. The primary actor selects the customer organisations that may use the pluggable device and submits the selection.
                % InfrastructureOwnerClient -> InfrastructureOwnerFacade: interface AccessRights: updateAccessRights(PluggableDeviceID id, Map<int, AccessRights> accessRights)

            7. The system
                { updates the roles of the selected customer organisations, giving them access rights to the pluggable device.
                    % InfrastructureOwnerFacade -> AccessRightsManager:  interface AccessRightsMgmt: updateAccessRights(PluggableDeviceID id, Map<int, AccessRights> accessRights)
                    % AccessRightsManager -> DeviceDB:                   interface DeviceMgmt:       updateAccessRights(PluggableDeviceID id, Map<int, AccessRights> accessRights)
                { checks and activates 'inactive' applications for the customer organisations with updated access rights (Include: UC17: Activate an application).
                    % InfrastructureOwnerFacade -> ApplicationManager:  interface IOAppMgmt: checkApplicationsForActivationForCustomerOrganisations(List<int> custOrgIDs)
                { checks for applications that require deactivation because of the unavailability of pluggable devices
                    % InfrastructureOwnerFacade -> ApplicationManager:  interface IOAppMgmt: checkApplicationsForDeactivationForCustomerOrganisations(List<int> custOrgIDs)


    \paragraph{U2: Easy applications}
        Applications should work out of the box if the required sensors and
        actuators are available. Only when mandatory end-user roles must be
        assigned, additional explicit configuration actions are required
        from a customer organisation (cf. UC17, UC19). \\
        *) if there is a subsription and new hardware is plugged in: need something to check
           if some application can be activated now => see UC6: checkApplicationsForActivationForInfrastructureOwner
        *) need something to assign user roles to users during UC19

        UC17: Activate an application
            ApplicationManager is triggered by something else do to the following: activateApplication(int applicationInstanceID)
            could be triggered because of: new pluggable device detected, new subscription, changed topology, new version of application

            1. The system checks that all mandatory roles have been assigned to end-users.
                % ApplicationManager -> UserRolesManager: interface RoleMgmt:     boolean checkMandatoryUserRoles(int applicationInstanceID)
                % UserRolesManager -> Database:           interface UserRoleMgmt: boolean checkMandatoryUserRoles(int applicationInstanceID)
                // returns true if all mandatory user roles for the application have been assigned to users
                // can find the customer organisation through the ApplicationInstance, because instances are for cust orgs

            2. If all mandatory roles have been assigned, the system checks that all necessary pluggable devices are available in the topology.
                // pluggable device status has to be 'active' in the DB, and status has to be 'placed/available' in the topology
                % ApplicationManager -> DeviceDB:        interface AppDeviceMgmt: List<DeviceInfo> getDevicesForApplication(int applicationInstanceID)
                % ApplicationManager -> TopologyManager: interface TopologyMgmt:  boolean arePluggableDevicesActive(List<PluggableDeviceID> devices) // check that they are all 'placed'. If a pluggable device is 'inactive' (because disconnected), then it is automatically 'unplaced' in the topology, so no need to also explicitly check device status
                % TopologyManager -> DeviceDB:           interface TopologyMgmt:  boolean arePluggableDevicesActive(List<PluggableDeviceID> devices)

            3. If all necessary pluggable devices are available, the system activates all necessary parts of the application on gateways and in the Online Service.
                FOR RATIONALE: we add ApplicationContainer component that will contain application INSTANCES in some kind of sandbox environment. The container can run/pause/stop these instances

                % ApplicationManager -> GatewayFacade:     interface AppMgmt:    activateAllApplicationParts(int applicationInstanceID) // activate all necessary parts of the application on gateways, whatever "all parts" means
                % GatewayFacade -> GWApplicationContainer: interface AppMgmt:    activateAllApplicationParts(int applicationInstanceID)
                % ApplicationManager -> ApplicationContainer: interface AppMgmt: activateAllApplicationParts(int applicationInstanceID) // activate all necessary parts of the application in the online service, whatever "all parts" means

            4. The system marks the application as 'active' and updates the billing information.
                % ApplicationManager -> Database: interface AppMgmt:       updateApplication(int applicationInstanceID, string status) // status = 'active'
                % ApplicationManager -> InvoiceManager: interface InvoiceMgmt: markActivatedApplication(int applicationInstanceID, int custOrgID, Date date) // updates billing information, marks the start of a period
                % InvoiceManager -> Database: interface: InvoiceMgmt:          markActivatedApplication(int applicationInstanceID, int custOrgID, Date date)

            5. The system sends a notication to the customer organisation subscribed to the application, to inform them that the application is running (Include: UC15: Send notication).
                % ApplicationManager -> NotificationManager: interface Notify: notify(int userID, string message)

            6. The system sends an SMS or e-mail to the end-users that were assigned roles. Possibly, this contains instructions for the end-user on how to install a mobile app linked to the application.
                % ApplicationManager -> UserRolesManager:    interface RoleMgmt:     List<User> getUsersWithRoles(int custOrgID)
                % UserRolesManager -> Database:              interface UserRoleMgmt: List<User> getUsersWithRoles(int custOrgID)
                % ApplicationManager -> Database:            interface AppMgmt:  string getInstallationInstructions(applicationID) // applications optionally have some installation instruction
                % ApplicationManager -> NotificationManager: interface Notify:       notify(int userID, string message)

            ALTERNATIVE SCENARIOS:
                2a. If end-users are not assigned to each mandatory role, the application is added as an 'inactive'
                application and the subscription info is set accordingly. The system notifies the customer
                organisation subscribed to the application (Include: UC15: Send notication). The use case ends.
                    This happens if checkMandatoryUserRoles returned false.
                    FOR RATIONALE: the UC is called "activate application", thus we assume the system already contains the
                                   application instance and subscription information, but the instance is 'inactive' at the start of the UC
                    => OK

                3a. If not all pluggable devices necessary for the application are available, the application is added
                as an 'inactive' application and the subscription info is set accordingly. The system notifies
                the customer organisation subscribed to the application (Include: UC15: Send notication). The use case ends.
                    This happens if arePluggableDevicesActive returned false.
                    Same as 2a. => OK

        UC19: Subscribe to application
            A customer organisation subscribes to an application via the dashboard.

            REMARKS:
                *) This use case concerns both subscribing to a new application, as well as upgrading an existing
                   application to a newer version (if this is not an automatic update, as indicated in UC22 : Upload an application).
                *) Roles in an application can be used to indicate which end-user(s) should be notified in case of specific events.
                *) It is possible to reassign end-users to roles later on. For simplicity, no separate use case is provided for this.

            1. The primary actor indicates they want to subscribe to an application.
                    % CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: Map<Application, Subscription> getApplicationsToSubscribe(int custOrgID)

            2. The system looks up the available applications (i.e., those to which the primary actor is not yet subscribed,
               or applications for which a newer version is available that requires a new subscription).
                    % CustomerOrganisationFacade -> SubscriptionManager: interface SubscriptionMgmt: Map<Application, Subscription> getApplicationsToSubscribe(int custOrgID)
                    % SubscriptionManager -> ApplicationManager:         interface Apps:             List<Application> getApplications()
                    % ApplicationManager -> Database:                    interface AppMgmt:      List<Application> getApplications()
                    % SubscriptionManager -> Database:                   interface SubscriptionMgmt: List<Subscription> getSubscriptions(int custOrgID)

            3. The system presents the available applications to the primary actor, e.g. as a list or table,
               thereby indicating whether it is a new application or an update.
                    % = return value of getApplicationsToSubscribe

            4. The primary actor selects the desired application.
                    % CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: int subscribeToApplication(int custOrgID, int applicationID)
                    % CustomerOrganisationFacade -> ApplicationManager:         interface Apps:             int createNewApplicationInstance(int custOrgID, int applicationID)
                    % ApplicationManager -> Database:                           interface AppMgmt:      int createNewApplicationInstance(int custOrgID, int applicationID) // returns an application instance id
                    % // subscribes the customer org to the application or updates the subscription if the org is already subscribed

            5. The system checks which topology configuration and selection of pluggable devices for the application are necessary
               (e.g., to indicate in which rooms a heating control application should run)
               and presents a topology allowing the primary actor to indicate their configuration.
                    % CustomerOrganisationFacade -> ApplicationManager: interface Apps:         List<RoomTopology> getNecessaryDevicesAndTopologyConfigurations(int applicationID) // load this data to display rules of the application in the UI
                    % ApplicationManager -> Database:                   interface AppMgmt:  List<RoomTopology> getNecessaryDevicesAndTopologyConfigurations(int applicationID) // load this data to display rules of the application in the UI
                    % CustomerOrganisationFacade -> TopologyManager:    interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID) // load the topology of the customer organisation
                    % TopologyManager -> DeviceDB:                      interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID) // load the topology of the customer organisation

            6. The primary actor carries out the topology configuration.
                    % // update the topology settings for the application instance = which devices the application will use for different things + relationships between the devices
                    % CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: void updateApplicationDevicesSettings(int applicationInstanceID, List<PluggableDeviceID> devices, List<Relationships> relationships)
                    % CustomerOrganisationFacade -> ApplicationManager:         interface Apps:             void updateApplicationDevicesSettings(int applicationInstanceID, List<PluggableDeviceID> devices, List<Relationships> relationships)
                    % ApplicationManager -> Database:                           interface AppMgmt:      void updateApplicationDevicesSettings(int applicationInstanceID, List<PluggableDeviceID> devices, List<Relationships> relationships)

            7. The system loads the (mandatory and optional) roles to which end-users have to be (or can be) assigned for that application.
                    % CustomerOrganisationFacade -> UserRolesManager: interface RoleMgmt:     List<UserRole> getAllUserRoles(int applicationID)
                    % UserRolesManager -> Database:                   interface UserRoleMgmt: List<UserRole> getAllUserRoles(int applicationID)
                    UserRole contains isMandatory member

            8. The system loads the end-users associated with the primary actor, presents them to the primary actor, and requests to assign end-users to the roles in the application.
                    % CustomerOrganisationFacade -> UserRolesManager: interface RoleMgmt:     List<User> getEndUsers(int custOrgID)
                    % UserRolesManager -> Database:                   interface UserRoleMgmt: List<User> getEndUsers(int custOrgID)

            9. The primary actor provides end-users for the roles.
                    % CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: updateUserRoles(int applicationInstanceID, map<int, int> usersAndRoles)
                    % CustomerOrganisationFacade -> UserRolesManager:           interface RoleMgmt:         updateUserRoles(int applicationInstanceID, map<int, int> usersAndRoles)
                    % UserRolesManager -> Database:                             interface UserRoleMgmt:     updateUserRoles(int applicationInstanceID, map<int, int> usersAndRoles)
                    can users have multiple roles? => no, only one

            10. The system asks the primary actor if this application should be considered a critical application (cf. P2 : Requests to the pluggable data database).
                    % CustomerOrganisationClient moves to the next page = form asking for criticality of app

            11. The primary actor indicates the criticality of the application.
                    % CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: updateCriticality(int applicationInstanceID, bool isCritical)

            12. The system registers the subscription and criticality of the application.
                    % CustomerOrganisationFacade -> SubscriptionManager:        interface SubscriptionMgmt: createSubscription(int custOrgID, int applicationInstanceID)
                    % // applicationInstanceID contains an application version member,
                    % // If the selected application is a newer version of an application to which the primary actor was previously subscribed, the primary actor is automatically unsubscribed from that earlier version
                    % SubscriptionManager -> Database:                          interface SubscriptionMgmt: createSubscription(int custOrgID, int applicationInstanceID)
                    % CustomerOrganisationFacade -> ApplicationManager:         interface Apps:             updateCriticality(int applicationInstanceID, bool isCritical)
                    % ApplicationManager -> Database:                           interface AppMgmt:      updateCriticality(int applicationInstanceID, bool isCritical)

            13. If the selected application is a newer version of an application to which the primary actor was previously subscribed,
                the primary actor is automatically unsubscribed from that earlier version (cf. step 4 or UC20 : Unsubscribe from application).
                    % See step 12 method createSubscription

            14. The system activates the application (Include: UC17 : Activate an application).
                    % CustomerOrganisationFacade -> ApplicationManager: interface Apps: activateApplication(int applicationInstanceID)


\subsection{Instantiation and allocation of functionality}
    This section describes the new components which instantiate our solutions described
    in the section above and how components are deployed on physical nodes. \\
    Unless stated otherwise the responsibilities assigned in the first decomposition are unchanged.

    \paragraph{Decomposition}
        Figure \ref{fig:FIGURELABEL} shows the components resulting from the
        decomposition in this run.

        \begin{figure}[!h]
        	\centering
            %\includegraphics[width=1\textwidth]{IMAGE FILE NAME}
        	\missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram of this decomposition}
        	\caption{Component-and-connector diagram of this decomposition.}
            \label{fig:FIGURELABEL}
        \end{figure}

        The responsibilities of the components are as follows:

    \subparagraph{Component}
        Short description of its responsibilities. (Relevant QA or UC)


    % \paragraph{Behaviour}
        % USEFUL SEQUENCE DIAGRAMS FOR CHOSEN USE CASES


    \paragraph{Deployment}
        Figure \ref{fig:FIGURELABEL} shows the allocation of components
        to physical nodes.

        \begin{figure}[!h]
        	\centering
        	%\includegraphics[width=0.8\textwidth]{IMAGE FILE NAME}
        	\missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
        	\caption{Deployment diagram of this decomposition.}
            \label{fig:FIGURELABEL}
        \end{figure}


\subsection{Interfaces for child modules}\label{add2-interfaces}
    This section describes the interfaces assigned to the components defined
    in the section above. Per interface, we list its methods by means of its
    syntax. The data types used in these interfaces are defined in the following section. \\

    Each method shows which (part of a) quality attribute or use case caused
    a need for the method. However, this does not mean that a method is
    only to be used to satisfy that quality  attribute or use case, it could
    be used for other causes not yet mentioned here.

    The interfaces and methods defined here are to be seen as an
    extension of the interfaces defined in previous sections, unless
    explicitly stated otherwise.

    \subsubsection{ApplicationManager}
        \begin{itemize}
            \item AppMgmt, last defined in section \ref{add1-interfaces}
                \begin{itemize}
                    \item \texttt{void checkApplicationsForActivationForInfrastructureOwner(int infrastructureOwnerID)}
                        \begin{itemize}
                			\item Effect: Checks and activates applications which can now execute again. Finds relevant applications through the customers of the given infrastructureOwnerID.
                			\item Created for: UC17 \\ UC6.3 - reintroduced device
                        \end{itemize}
                \end{itemize}

            \item IOAppMgmt
                \begin{itemize}
                    \item \texttt{void checkApplicationsForActivationForCustomerOrganisations(List<int> customerOrganisationIDs)}
                        \begin{itemize}
                			\item Effect: Checks and activates applications which can now execute again. Finds relevant applications through the given customerOrganisationIDs.
                			\item Created for: UC9.7 - checks and activates 'inactive' applications for the customer organisations with updated access rights \\ UC17
                        \end{itemize}
                    \item \texttt{void checkApplicationsForDeactivationForCustomerOrganisations(List<int> customerOrganisationIDs)}
                        \begin{itemize}
                			\item Effect: Checks and deactivates applications which that require deactivation because of the unavailability of pluggable devices.
                                  Only checks applications that are linked to the given customerOrganisationIDs.
                			\item Created for: UC9.7 - checks for applications that require deactivation \\ UC18
                        \end{itemize}
                \end{itemize}
        \end{itemize}

    \subsubsection{DeviceDB}
        \begin{itemize}
            \item DeviceMgmt
                \begin{itemize}
                    \item \texttt{int addMote(MoteInfo mote, int gatewayID, IPAddress moteIPAddress)}
                        \begin{itemize}
                            \item Effect: Schedules a DB query to add a new mote to the .
                            \item Created for: UC4.3
                        \end{itemize}
                    \item \texttt{void reactivateMote(int moteID)}
                        \begin{itemize}
                            \item Effect: Schedules a DB query to change the status of the mote to active.
                            \item Created for: UC4.3 - reintroduced mote
                        \end{itemize}
                    \item \texttt{void addDevice(PluggableDeviceID id, PluggableDeviceType type, Map<String, String> defaultConfigurations)}
                        \begin{itemize}
                            \item Effect: Schedules a DB query to add a new pluggable device to the .
                            \item Created for: UC6.3
                        \end{itemize}
                    \item \texttt{void reactivateDevice(PluggableDeviceID id)}
                        \begin{itemize}
                            \item Effect: Schedules a DB query to change the status of the pluggable device to active.
                            \item Created for: UC6.3 - reintroduced device
                        \end{itemize}
                    \item \texttt{Map<String, String> getConfigDB(PluggableDeviceID pID)}
                        \begin{itemize}
                            \item Effect: Schedules a DB query to get the last set configuration of a pluggable device.
                            \item Created for: UC6.3 - reintroduced device
                        \end{itemize}
                    \end{itemize}
                \end{itemize}

        	\item TopologyMgmt
            	\begin{itemize}
            		\item \texttt{void addMoteInTopology(int moteID, int infrastructureOwnerID, int gatewayID)}
                		\begin{itemize}
                            \item Effect: Schedules a DB query to add a new mote in the topology.
                			\item Created for: UC4.3
                		\end{itemize}
                    \item \texttt{void reactivateMoteInTopology(int moteID)}
                        \begin{itemize}
                            \item Effect: Schedules a DB query to change the status of the mote in the topology to 'placed'.
                            \item Created for: UC4.3 - reintroduced mote
                        \end{itemize}
                    \item \texttt{void addDevice(PluggableDeviceID id, int moteID)}
                        \begin{itemize}
                            \item Effect: Schedules a DB query to add a new pluggable device to the topology.
                            \item Created for: UC6.3
                        \end{itemize}
                    \item \texttt{void reactivateDevice(PluggableDeviceID id)}
                        \begin{itemize}
                            \item Effect: Schedules a DB query to change the status of the pluggable device to 'placed'.
                            \item Created for: UC6.3 - reintroduced device
                        \end{itemize}
            	\end{itemize}
        \end{itemize}

    \subsubsection{GatewayFacade}
        \begin{itemize}
            \item DeviceMgmt, last defined in section \ref{add1-interfaces}
            \begin{itemize}
                \item \texttt{int addMote(MoteInfo mote, int gatewayID, IPAddress moteIPAddress)}
                    \begin{itemize}
                        \item Effect: Sends a DB query to the DeviceDataScheduler to add the new mote. \\
                              Sends a request to the TopologyManager to add the new mote to the topology of the infrastructure owner.
                        \item Created for: UC4.3
                    \end{itemize}
                \item \texttt{void reactivateMote(int moteID)}
                    \begin{itemize}
                        \item Effect: Sends a DB query to the DeviceDataScheduler to reactivate the mote. \\
                              Sends a request to the TopologyManager to update the mote's topology status.
                        \item Created for: UC4.3 - reintroduced mote
                    \end{itemize}
                \item \texttt{void addDevice(PluggableDeviceID id, PluggableDeviceType type, Map<String, String> defaultConfigurations, int moteID)}
                    \begin{itemize}
                        \item Effect: Sends a DB query to the DeviceDataScheduler to add the new device. If the device already exists, removes the data first. The device's status is 'uninitialised' by default. \\
                              Sends a request to the TopologyManager to add the new device to the topology and link it to a mote.
                        \item Created for: UC6.3
                    \end{itemize}
                \item \texttt{void reactivateDevice(PluggableDeviceID id)}
                    \begin{itemize}
                        \item Effect: Sends a DB query to the DeviceDataScheduler to reactivate the device. Marks the pluggable device as 'active'. \\
                              Sends a request to the TopologyManager to update the device's topology status.
                        \item Created for: UC6.3 - reintroduced device
                    \end{itemize}
                \item \texttt{void notifyNewMote(int moteID, MoteInfo mote)}
                    \begin{itemize}
                        \item Effect: Lets the gateway know that a new mote has been installed in the system.
                              This will generate a notification for an infrastructure owner.
                        \item Created for: UC4.4
                    \end{itemize}
                \item \texttt{void notifyReactivatedMote(int moteID, MoteInfo mote)}
                    \begin{itemize}
                        \item Effect: Lets the gateway know that a mote has been reactivated in the system.
                              This will generate a notification for an infrastructure owner.
                        \item Created for: UC4.4
                    \end{itemize}
                \item \texttt{void notifyNewPluggableDevice(PluggableDeviceID id, PluggableDeviceType type, Map<String, String> defaultConfigurations)}
                    \begin{itemize}
                        \item Effect: Lets the gateway know that a new device has been installed in the system.
                              This will generate a notification for an infrastructure owner.
                        \item Created for: UC6.3
                    \end{itemize}
                \item \texttt{void notifyReactivatedPluggableDevice(PluggableDeviceID id, PluggableDeviceType type, Map<String, String> defaultConfigurations)}
                    \begin{itemize}
                        \item Effect: Lets the gateway know that a pluggable device has been reactivated in the system.
                              This will generate a notification for an infrastructure owner.
                        \item Created for: UC6.3
                    \end{itemize}
                \item \texttt{void setConfig(PluggableDeviceID pID, Map<String, String> config)}
                    \begin{itemize}
                        \item Now also used for UC6.3 - reintroduced device
                    \end{itemize}
                \item \texttt{Map<String, String> getConfigDB(PluggableDeviceID pID)}
                    \begin{itemize}
                        \item Effect: Sends a DB query to the DeviceDataScheduler to get the last set configuration of a pluggable device.
                        \item Created for: UC6.3 - reintroduced device
                    \end{itemize}
            \end{itemize}

            \item AppMgmt, last defined in section \ref{add1-interfaces}
                \begin{itemize}
                    \item \texttt{void checkApplicationsForActivationForInfrastructureOwner(int infrastructureOwnerID)}
                        \begin{itemize}
                			\item Effect: Forwards this request to the ApplicationManager.
                                  Used by DeviceManager after connecting a pluggable device.
                			\item Created for: UC17 \\  UC6.3 - reintroduced device
                        \end{itemize}
                \end{itemize}
        \end{itemize}

    \subsubsection{MoteFacade}
        \begin{itemize}
            \item DeviceMgmt, last defined in section \ref{add1-interfaces}
            \begin{itemize}
                \item \texttt{void setConfig(PluggableDeviceID pID, Map<String, String> config)}
                \begin{itemize}
                    \item Now also used for UC6.3 - reintroduced mote
                \end{itemize}
            \end{itemize}
        \end{itemize}

    \subsubsection{PluggableDeviceFacade}
        \begin{itemize}
        	\item Config, last defined in section \ref{add1-interfaces}
        	\begin{itemize}
                \item \texttt{boolean setConfig(Map<String, String> config)}
                    \begin{itemize}
                        \item Now also used for UC6.3 - reintroduced mote
                    \end{itemize}
            \end{itemize}
        \end{itemize}

    \subsubsection{TopologyManager}
        \begin{itemize}
        	\item TopologyMgmt
        	\begin{itemize}
        		\item \texttt{void addMote(int moteID, int infrastructureOwnerID, int gatewayID)}
            		\begin{itemize}
            			\item Effect: Sends a DB query to the DeviceDataScheduler to add a mote to the topology. Its status is 'unplaced' by default.
            			\item Created for: UC4.3
            		\end{itemize}
                \item \texttt{void reactivateMote(int moteID)}
                    \begin{itemize}
                        \item Effect: Sends a DB query to the DeviceDataScheduler to change the status of the mote to 'placed'.
                        \item Created for: UC4.3 - reintroduced mote
                    \end{itemize}
                \item \texttt{void addDevice(PluggableDeviceID id, int moteID)}
                    \begin{itemize}
                        \item Effect: Sends a DB query to the DeviceDataScheduler to add a device in the topology and link it to a mote.
                              The device gets the mote's location by default. If the device is already linked to another mote, overwrite that link.
                        \item Created for: UC6.3
                    \end{itemize}
                \item \texttt{void reactivateDevice(PluggableDeviceID id)}
                    \begin{itemize}
                        \item Effect: Sends a DB query to the DeviceDataScheduler to change the status of the device to 'placed'.
                        \item Created for: UC6.3 - reintroduced device
                    \end{itemize}
        	\end{itemize}
        \end{itemize}


\subsection{Data type definitions}
    This section defines new data types that are used in the interface descriptions above.

    \paragraph{DataType}
        Description of data type
