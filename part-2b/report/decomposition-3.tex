\section{Decomposition 3: U2, UC4, UC6, UC9, UC10, UC17, UC19}


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{U2}: Easy installation
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC4}: Install mote
        \item \emph{UC6}: Insert a pluggable device into a mote
        \item \emph{UC9}: Configure pluggable device access rights
        \item \emph{UC10}: Consult and configure topology
        \item \emph{UC17}: Activate an application
        \item \emph{UC19}: Subscribe to application
    \end{itemize}


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    Did you ever hear the tragedy of Darth Plagueis The Wise? I thought not. It's not a story the Jedi would tell you. It's a Sith legend. Darth Plagueis was a Dark Lord of the Sith, so powerful and so wise he could use the Force to influence the midichlorians to create life... He had such a knowledge of the dark side that he could even keep the ones he cared about from dying. The dark side of the Force is a pathway to many abilities some consider to be unnatural. He became so powerful... the only thing he was afraid of was losing his power, which eventually, of course, he did. Unfortunately, he taught his apprentice everything he knew, then his apprentice killed him in his sleep. Ironic. He could save others from death, but not himself.


    % Some dabatase tables text we wrote:
    %     pluggable\_devices
    %     topology\_pluggable\_devices
    %     permissions\_pluggable\_devices
    %
    %     topology
    %         gateways(id, floor, room\_number, wall, status)
    %         motes(id, gateway\_id, floor, room\_number, status)
    %         pluggable\_devices(id, mote\_id, gateway\_id, status, physical location)
    %         % pluggable\_devices\_redundancies(deviceID1, deviceID2)
    %         pluggable\_devices\_relationships(deviceID1, deviceID2, type)
    %
    %         Relationship
    %             PluggableDeviceID device1
    %             PluggableDeviceID device2
    %             string type
    %
    %             Relationship(fireDetector, smokeDetector, "redundancy")
    %             Relationship(fireDetector, smokeDetector, \">")
    %
    %         RoomTopology:
    %             int roomID
    %             List<PluggableDeviceInfo> devices
    %             List<Relationship> devices\_relationships
    %
    %     access rights
    %         rights(id, origranisation\_id, device\_id, can\_read, can\_configure, can\_send\_actuation\_command)

    \paragraph{U2: Gateway installation}
        The gateway should not require any configuration, other than being connected
        to the local wired or WiFi network, after it is plugged into an electrical
        socket. An infrastructure owner should be able get the SIoTIP gateway
        up-and-running (connected) within 10 minutes given that the information
        (e.g. WiFi SSID and passphrase) is available to the person responsible for
        the installation. \\

        A connection to the internet is a constraint of the GatewayFacade.
        After the gateway is connected to the internet (we don't model this),
        it connects to the gateway (we don't model this?) and registers itself (we model this). \\
        When an infrastructure owner orders a gateway, that gateway is linked to the IO.
        Gateway was already in the DeviceDB, but it was not linked to anyone. It has a gatewayID => unique identifier gatewayID same like motes.

        Important info related to gateways: GatewayID (new class), infrastructureOwnerID, IPAddress, status (active/inactive), location (in topology table)
            GatewayInfo(int gatewayID, int manufacturerID, int productID, int infrastructureOwnerID, IPAddress ip, int status)

        gateway registers with online service:
            % GatewayFacade -> DeviceDB: interface DeviceMgmt: registerGateway(int gatewayID, IPAddress address)
            %     Effect: Sets a gateway's status to 'active' and updates its IP address
            %     \item Created for: U2 - gateway installation
            TODO: gateway is added in the infrastructure owners topology as 'unplaced'.
                  it will be visible to the infrastructure owner after the gateway connects and registers with the online service

            We cannot link the gateway to an exact location for the infrastructure owner, because he might be managing multiple buildings
            an IP addresses can be dynamic. If we let the IO choose for which building the gateway is, then this is bad for usability and
            he has to configure anyways. Also in that case he cannot buy spare gateways, unless he buys spare gateways for every gateway in the building


    \paragraph{U2: Mote installation}
        Installing a new mote should not require more configuration than adding it
        to the topology. Adding new motes, sensors or actuators should not involve
        more than just starting motes, and plugging devices into motes – plug-and-play!
        Reintroducing a previously known mote, with the same pluggable devices attached to it,
        should not require any configuration. It is automatically re-added on
        its last known location on the topology. The attached pluggable devices
        are automatically initialised and configured with their last known
        configuration and access rights. \\
        Thing that need to happen automatically:
        *) mote should find the gateway (mote sends a broadcast message->ReceiveBroadcast) => this is done automatically? see remarks of the use case
        *) gateway should register the mote (DeviceManager update, store entry in DB)
        *) on reintroduction of motes: DeviceManager notices this, makes the gateway send a message to online service to reuse some old topology

        % UC4:
        %     Remark : The mote is pre-congured to connect to a specic gateway by
        %      the hardware manufacturer. This linking process is out of scope for
        %      this assignment. Likewise, the automatic assignment of an IPv6 address
        %      to the mote is out of scope.
        %
        %     if new mote:
        %         for step 2., we can use the heartbeat system. heartbeat is sent from mote to gateway,
        %         the DeviceManager in the gateway notices that this is from a new mote and starts
        %         the registerMote procedure
        %         FOR RATIONALE: The IPAddress of the mote can be parsed out of the 6lowpan header in the heartbeat messages
        %         ALTERNATIVE IS GatewayFacade: registerMote, but this is more work (battery power and implementation)
        %
        %         FOR RATIONALE: be careful with int moteID. when we register, we send MoteInfo to the DB, DB returns a DIFFERENT int moteID we use the other moteID in the rest of the system
        %         3. DeviceManager -> GatewayFacade:       interface DeviceMgmt:   int moteID addMote(MoteInfo mote, int gatewayID, IPAddress moteIPAddress)
        %         3. GatewayFacade -> DeviceDB:            interface DeviceMgmt:   int moteID addMote(MoteInfo mote, int gatewayID, IPAddress moteIPAddress)
        %         3. GatewayFacade -> TopologyManager:     interface TopologyMgmt: void addMote(int moteID, int infrastructureOwnerID, int gatewayID)
        %         3. TopologyManager -> DeviceDB:          interface TopologyMgmt: void addMote(int moteID, int infrastructureOwnerID, int gatewayID)
        %         4. GatewayFacade -> NotificationHandler: interface Notify:       notify(int userID, string message)
        %
        % if reintroduced mote:
        %     It is automatically re-added on its last known location on the topology.
        %         3. DeviceManager -> GatewayFacade:   interface DeviceMgmt:    void reactivateMote(int moteID)
        %         3. GatewayFacade -> DeviceDB:        interface DeviceMgmt:    void reactivateMote(int moteID)
        %         3. GatewayFacade -> TopologyManager: interface TopologyMgmt:  void reactivateMote(int moteID)
        %         3. TopologyManager -> DeviceDB:      interface TopologyMgmt:  void reactivateMote(int moteID)
        %
        %     The attached pluggable devices are automatically initialised and configured with their last known configurations and access rights.
        %         See UC6 - reintroduced device


    \paragraph{U2: Pluggable device installation}
        Adding new sensors or actuators should require no further customer
        actions besides plugging it into the mote. Configurable sensors and
        actuators should have a working default configuration.
        Pluggable devices added to an already known mote are automatically
        added in the right location on the topology.
        Making (initialised) sensors and actuators available to customer
        organisations and applications should not require more effort than
        configuring access rights (cf. UC9). \\
        *) After devices are plugged in: connect to mote, set up default configurations
        *) if the mote is already known, the device is added to the right location on the topology
        *) need something for configuration of access rights, can only happen for initialised devices

        *) for reactivating last configurations: just set status to active and don't change configuration field, it will still be the same as in the past
            alternative: current\_configuration and last\_configuration in DB
            alternative: store all configurations on Gateway -> but it has bad resources
            alternative: store all versions on DeviceDB -> but lots of useless data then = extra work for db

        *) Pluggable devices added to an already known mote are automatically added in "the right location" on the topology.
            what exactly is a location?
            => when a pluggable device is connected to a new mote, the pluggable device gets the location of the mote by default

        % UC6: insert a pluggable device into a mote
        %     mote is already installed
        %
        %     when device is plugged into a mote:
        %         2. The system receives a message from the mote, informing it of the new pluggable device. This
        %         message species the identier and type of the new pluggable device.
        %         => for registration, we can use the heartbeat system. heartbeat is sent from mote to gateway,
        %         the DeviceManager in the gateway notices that there is a new pluggable device
        %
        %         Status of new pluggable devices will be 'uninitialised' by default in the DB, and 'unplaced' in topology
        %         New pluggable devices get the location of the mote in the topology, but have status unplaced
        %
        %         DeviceManager -> GatewayFacade:   interface DeviceMgmt:   void addDevice(PluggableDeviceID id, PluggableDeviceType type, Map<string, string> defaultConfigurations, int moteID)
        %         GatewayFacade -> DeviceDB:        interface DeviceMgmt:   void addDevice(PluggableDeviceID id, PluggableDeviceType type, Map<string, string> defaultConfigurations, int moteID)
        %         GatewayFacade -> TopologyManager: interface TopologyMgmt: void addDevice(PluggableDeviceID id, int moteID)
        %         TopologyManager -> DeviceDB:      interface TopologyMgmt: void addDevice(PluggableDeviceID id, int moteID)
        %
        %         In these methods, if the device already exists and is plugged in in another mote, clear the data
        %
        %         For default configurations: when it is a new device, we assume that the defaults are turned on by default so we don't have to do anything here
        %
        %     if the device is a known previously active device (ON THE SAME MOTE):
        %         ∗ marks the pluggable device as ‘active':
        %             DeviceManager -> GatewayFacade: interface DeviceMgmt: void reactivateDevice(PluggableDeviceID id)
        %             GatewayFacade -> DeviceDB:      interface DeviceMgmt: void reactivateDevice(PluggableDeviceID id)
        %
        %         ∗ updates the topology:
        %             GatewayFacade -> TopologyManager: interface TopologyMgmt: void reactivateDevice(PluggableDeviceID id)
        %             TopologyManager -> DeviceDB:      interface TopologyMgmt: void reactivateDevice(PluggableDeviceID id)
        %
        %         ∗ configures the pluggable device with the last known access rights:
        %             RATIONALE: nothing needs to happen here, permission information will just not be used if the device is inactive
        %                        if the device is reactivated, the permissions are already there
        %
        %         * configures the pluggable device with the last known configuration:
        %             DeviceManager -> GatewayFacade:      interface DeviceMgmt: Map<string, string> getConfigDB(PluggableDeviceID id)
        %             GatewayFacade -> DeviceDB:           interface DeviceMgmt: Map<string, string> getConfigDB(PluggableDeviceID id)
        %             DeviceManager -> Mote:         interface DeviceMgmt: void setConfig(PluggableDeviceID device, Map<string, string> config)
        %             Mote -> PluggableDevice: interface Config:     void setConfig(Map<string, string> config)
        %
        %         ∗ checks and activates applications which can now execute again:
        %             RATIONALE: gateway sends id of IO instead of fetching customers of IO. the online service will do that extra work = less work for gateway.
        %             DeviceManager -> GatewayFacade:      interface DeviceMgmt: checkApplicationsForActivationForInfrastructureOwner(int infrastructureOwnerID)
        %             GatewayFacade -> ApplicationManager: interface AppMgmt: checkApplicationsForActivationForInfrastructureOwner(int infrastructureOwnerID)
        %
        %         * send notification
        %             GatewayFacade -> NotificationHandler: interface Notify:       notify(int userID, string message)

        % UC9: configure pluggable device access rights
        %     Map<int, AccessRights> : maps customerOrganisationIDs to their AccessRights
        %
        %     1. The primary actor indicates that they want to configure the access rights to pluggable devices.
        %         InfrastructureOwnerClient -> InfrastructureOwnerFacade: interface AccessRights: List<PluggableDeviceInfo> getAccessRights(int infrastructureOwnerID)
        %             Effect: Returns a list of PluggableDeviceInfo to display so an infrastructure owner can select a device to configure access rights.
        %             \item Created for: UC9.1
        %
        %     2. The system retrieves the list of pluggable devices associated with the primary actor and presents these to the primary actor.
        %         InfrastructureOwnerFacade -> InfrastructureOwnerManager: interface IOMgmt:     List<PluggableDeviceInfo>  getDevices(int infrastructureOwnerID)
        %             Effect: Returns a list of PluggableDeviceInfo of devices owned by an infrastructure owner.
        %             \item Created for: UC9.2
        %         InfrastructureOwnerManager -> DeviceDB:                  interface IODeviceMgmt: List<PluggableDeviceInfo>  getDevices(int infrastructureOwnerID)
        %             Effect: Returns a list of PluggableDeviceInfo of devices owned by an infrastructure owner.
        %             \item Created for: UC9.2
        %         presents these to the primary actor = return of getAccessRights(int infrastructureOwnerID)
        %
        %     3. The primary actor indicates for which pluggable device they want to configure the access rights.
        %         InfrastructureOwnerClient -> InfrastructureOwnerFacade: interface AccessRights: Map<int, AccessRights> configureDevice(PluggableDeviceID id)
        %             Effect: Returns a map of AccessRights and the IDs of customer organisations that have those AccessRights.
        %             \item Created for: UC9.3 - UC9.4
        %
        %     4. The system retrieves all customer organisations associated with the primary actor and presents these to the primary actor,
        %        thereby indicating which of these customer organizations already have access to the pluggable device.
        %         InfrastructureOwnerFacade -> InfrastructureOwnerManager: interface IOMgmt:           List<int> getCustomerOrganisations(int infrastructureOwnerID)
        %             Effect: Returns a list of IDs of all customer organisations associated with an infrastructure owner.
        %             \item Created for: UC9.4
        %         InfrastructureOwnerManager -> OtherDataDB:               interface IOMgmt:           List<int> getCustomerOrganisations(int infrastructureOwnerID)
        %             Effect: Returns a list of IDs of all customer organisations associated with an infrastructure owner.
        %             \item Created for: UC9.4
        %         InfrastructureOwnerFacade -> AccessRightsManager:        interface AccessRightsMgmt: Map<int, AccessRights> getCustomerOrganisationsRights(PluggableDeviceID id, List<int> custOrgIDs)
        %             Effect: Returns a map of AccessRights and the IDs of customer organisations that have those AccessRights on a certain pluggable device.
        %             \item Created for: UC9.4
        %         AccessRightsManager -> DeviceDB:                         interface AccessRightsMgmt: Map<int, AccessRights> getCustomerOrganisationsRights(PluggableDeviceID id, List<int> custOrgIDs)
        %             Effect: Returns a map of AccessRights and the IDs of customer organisations that have those AccessRights on a certain pluggable device.
        %             \item Created for: UC9.4
        %
        %     5. The system asks to indicate which of these should have access to the pluggable device.
        %         = is return value of configureDevice(PluggableDeviceID id)
        %
        %     6. The primary actor selects the customer organisations that may use the pluggable device and submits the selection.
        %         InfrastructureOwnerClient -> InfrastructureOwnerFacade: interface AccessRights: void updateAccessRights(PluggableDeviceID id, Map<int, AccessRights> accessRights)
        %             Effect: Updates the access rights on a certain pluggable device for a group of customer organisations.
        %             \item Created for: UC9.6
        %
        %     7. The system
        %         { updates the roles of the selected customer organisations, giving them access rights to the pluggable device.
        %             InfrastructureOwnerFacade -> AccessRightsManager:  interface AccessRightsMgmt: void updateAccessRights(PluggableDeviceID id, Map<int, AccessRights> accessRights)
        %                 Effect: Updates the access rights on a certain pluggable device for a group of customer organisations.
        %                 \item Created for: UC9.7
        %             AccessRightsManager -> DeviceDB:                   interface AccessRightsMgmt: void updateAccessRights(PluggableDeviceID id, Map<int, AccessRights> accessRights)
        %                 Effect: Updates the access rights on a certain pluggable device for a group of customer organisations.
        %                 \item Created for: UC9.7
        %         { checks and activates 'inactive' applications for the customer organisations with updated access rights (Include: UC17: Activate an application).
        %             InfrastructureOwnerFacade -> ApplicationManager:  interface IOAppMgmt: void checkApplicationsForActivationForCustomerOrganisations(List<int> custOrgIDs)
        %                 Effect: Checks and activates 'inactive' ApplicationInstances which can now execute again for a list of customer organisations.
        %                 \item Created for: UC9.7
        %         { checks for applications that require deactivation because of the unavailability of pluggable devices
        %             InfrastructureOwnerFacade -> ApplicationManager:  interface IOAppMgmt: void checkApplicationsForDeactivationForCustomerOrganisations(List<int> custOrgIDs)
        %                 Effect: Checks for ApplicationInstances that require deactivation for a list of customer organisations.
        %                 \item Created for: UC9.7


    \paragraph{U2: Easy applications}
        Applications should work out of the box if the required sensors and
        actuators are available. Only when mandatory end-user roles must be
        assigned, additional explicit configuration actions are required
        from a customer organisation (cf. UC17, UC19). \\
        *) if there is a subsription and new hardware is plugged in: need something to check
           if some application can be activated now => see UC6: checkApplicationsForActivationForInfrastructureOwner
        *) need something to assign user roles to users during UC19

        % UC17: Activate an application
        %     ApplicationManager is triggered by something else do to the following: activateApplication(int applicationInstanceID)
        %     could be triggered because of: new pluggable device detected, new subscription, changed topology, new version of application
        %
        %     1. The system checks that all mandatory roles have been assigned to end-users.
        %         ApplicationManager -> UserManager: interface RoleMgmt:     boolean areMandatoryUserRolesAssigned(int applicationInstanceID)
        %             Effect: Returns true if all mandatory UserRoles for the application have been assigned to users. Finds the relevant customer organisations through the ApplicationInstance.
        %             \item Created for: UC17.1, U2 - easy applications
        %         UserManager -> OtherDataDB:        interface UserRoleMgmt: boolean areMandatoryUserRolesAssigned(int applicationInstanceID)
        %             Effect: Returns true if all mandatory UserRoles for the application have been assigned to users. Finds the relevant customer organisations through the ApplicationInstance.
        %             \item Created for: UC17.1, U2 - easy applications
        %
        %     2. If all mandatory roles have been assigned, the system checks that all necessary pluggable devices are available in the topology.
        %         // pluggable device status has to be 'active' in the DB, and status has to be 'placed/available' in the topology
        %
        %         ApplicationManager -> OtherDataDB:     interface AppMgmt:       List<PluggableDeviceID> getDevicesForApplication(int applicationInstanceID)
        %             Effect: Returns a list of PluggableDeviceID of pluggable devices that an ApplicationInstance can use.
        %             \item Created for: UC17.2, U2 - easy applications
        %         ApplicationManager -> TopologyManager: interface TopologyMgmt:  boolean arePluggableDevicesPlaced(List<PluggableDeviceID> devices)
        %             Effect: Returns true if all pluggable devices in the given list have status 'placed' in the topology.
        %             \item Created for: UC17.2, U2 - easy applications
        %         TopologyManager -> DeviceDB:           interface TopologyMgmt:  boolean arePluggableDevicesPlaced(List<PluggableDeviceID> devices)
        %             Effect: Returns true if all pluggable devices in the given list have status 'placed' in the topology.
        %             \item Created for: UC17.2, U2 - easy applications
        %
        %     3. If all necessary pluggable devices are available, the system activates all necessary parts of the application on gateways and in the Online Service.
        %         FOR RATIONALE: we add ApplicationContainerManager component that will contain ApplicationInstanceS in some kind of sandbox environment. The container can run/pause/stop these instances
        %
        %         ApplicationManager -> GatewayFacade:               interface AppMgmt: void activateApplicationInstance(int applicationInstanceID)
        %             Effect: Activates an ApplicationInstance that is running on the gateway.
        %             \item Created for: UC17.3, U2 - easy applications
        %         GatewayFacade -> GW/ApplicationContainerManager:     interface AppMgmt: void activateApplicationInstance(int applicationInstanceID)
        %             Effect: Activates an ApplicationInstance that is running on the gateway.
        %             \item Created for: UC17.3, U2 - easy applications
        %         ApplicationManagementLogic -> ApplicationContainerManager: interface AppMgmt: void activateApplicationInstance(int applicationInstanceID)
        %             Effect: Activates an ApplicationInstance that is running on the online service.
        %             \item Created for: UC17.3, U2 - easy applications
        %
        %     4. The system marks the application as 'active' and updates the billing information.
        %         ApplicationManager -> OtherDataDB:    interface AppMgmt:     void activateApplication(int applicationInstanceID, string status)
        %             Effect: Sets an ApplicationInstance's status in the OtherDataDB to 'active'.
        %             \item Created for: UC17.4, U2 - easy applications
        %         ApplicationManager -> InvoiceManager: interface InvoiceMgmt: void markActivatedApplication(int applicationInstanceID, int custOrgID, DateTime date)
        %             Effect: Updates an ApplicationInstance's billing information: marks the start of a billing period.
        %             \item Created for: UC17.4, U2 - easy applications
        %         InvoiceManager -> OtherDataDB:        interface InvoiceMgmt: void markActivatedApplication(int applicationInstanceID, int custOrgID, DateTime date)
        %             Effect: Updates an ApplicationInstance's billing information: marks the start of a billing period.
        %             \item Created for: UC17.4, U2 - easy applications
        %
        %     5. The system sends a notication to the customer organisation subscribed to the application, to inform them that the application is running (Include: UC15: Send notication).
        %         ApplicationManager -> NotificationHandler: interface Notify: notify(int userID, string message)
        %
        %     6. The system sends an SMS or e-mail to the end-users that were assigned roles. Possibly, this contains instructions for the end-user on how to install a mobile app linked to the application.
        %         ApplicationManager -> UserManager:    interface RoleMgmt:     List<User> getUsersWithRoles(int applicationInstanceID)
        %             Effect: Returns a list of Users associated to an ApplicationInstance that were assigned UserRoles.
        %             \item Created for: UC17.6, U2 - easy applications
        %         UserManager -> OtherDataDB:           interface UserRoleMgmt: List<User> getUsersWithRoles(int applicationInstanceID)
        %             Effect: Returns a list of Users associated to an ApplicationInstance that were assigned UserRoles.
        %             \item Created for: UC17.6, U2 - easy applications
        %         ApplicationManager -> OtherDataDB:         interface AppMgmt:      string getInstallationInstructions(int applicationID)
        %             Effect: Returns the installation instructions of a certain application. If there are no installation instructions set, returns an empty string.
        %             \item Created for: UC17.6, U2 - easy applications
        %         ApplicationManager -> NotificationHandler: interface Notify:       notify(int userID, string message)
        %
        %     ALTERNATIVE SCENARIOS:
        %         2a. If end-users are not assigned to each mandatory role, the application is added as an 'inactive'
        %         application and the subscription info is set accordingly. The system notifies the customer
        %         organisation subscribed to the application (Include: UC15: Send notication). The use case ends.
        %             This happens if areMandatoryUserRolesAssigned returned false.
        %             FOR RATIONALE: the UC is called "activate application", thus we assume the system already contains the
        %                            ApplicationInstance and subscription information, but the instance is 'inactive' at the start of the UC
        %             => OK
        %
        %         3a. If not all pluggable devices necessary for the application are available, the application is added
        %         as an 'inactive' application and the subscription info is set accordingly. The system notifies
        %         the customer organisation subscribed to the application (Include: UC15: Send notication). The use case ends.
        %             This happens if arePluggableDevicesPlaced returned false.
        %             Same as 2a. => OK

        % UC19: Subscribe to application
        %     A customer organisation subscribes to an application via the dashboard.
        %
        %     REMARKS:
        %         *) This use case concerns both subscribing to a new application, as well as upgrading an existing
        %            application to a newer version (if this is not an automatic update, as indicated in UC22 : Upload an application).
        %         *) Roles in an application can be used to indicate which end-user(s) should be notified in case of specific events.
        %         *) It is possible to reassign end-users to roles later on. For simplicity, no separate use case is provided for this.
        %
        %     1. The primary actor indicates they want to subscribe to an application.
        %             CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: Map<Application, Subscription> getApplicationsToSubscribe(int custOrgID)
        %                 Effect: Returns a map of Applications and Subscriptions a given customer organisation has to those applications
        %                 \item Created for: UC19.1, U2 - easy applications
        %
        %     2. The system looks up the available applications (i.e., those to which the primary actor is not yet subscribed,
        %        or applications for which a newer version is available that requires a new subscription).
        %             CustomerOrganisationFacade -> SubscriptionManager: interface SubscriptionMgmt: Map<Application, Subscription> getApplicationsToSubscribe(int custOrgID)
        %                 Effect: Returns a map of Applications and Subscriptions a given customer organisation has to those applications
        %                 \item Created for: UC19.2, U2 - easy applications
        %             SubscriptionManager -> ApplicationManager:            interface FrontEndAppMgmt:             List<Application> getApplications()
        %                 Effect: Returns a list of applications in the system.
        %                 \item Created for: UC19.2, U2 - easy applications
        %             ApplicationManager -> OtherDataDB:                    interface AppMgmt:          List<Application> getApplications()
        %                 Effect: Returns a list of applications in the system.
        %                 \item Created for: UC19.2, U2 - easy applications
        %             SubscriptionManager -> OtherDataDB:                   interface SubscriptionMgmt: List<Subscription> getSubscriptions(int custOrgID)
        %                 Effect: Returns a list of subscriptions a customer organisation has.
        %                 \item Created for: UC19.2, U2 - easy applications
        %
        %     3. The system presents the available applications to the primary actor, e.g. as a list or table,
        %        thereby indicating whether it is a new application or an update.
        %             = return value of getApplicationsToSubscribe
        %
        %     4. The primary actor selects the desired application.
        %             CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: int subscribeToApplication(int custOrgID, int applicationID)
        %                 Effect: Creates a new ApplicationInstance for an application for a customer organisation and returns its id.
        %                 \item Created for: UC19.4, U2 - easy applications
        %             CustomerOrganisationFacade -> ApplicationManager:         interface FrontEndAppMgmt:             int createNewApplicationInstance(int custOrgID, int applicationID)
        %                 Effect: Creates a new ApplicationInstance for an application for a customer organisation and returns its id.
        %                 \item Created for: UC19.4, U2 - easy applications
        %             ApplicationManager -> OtherDataDB:                        interface AppMgmt:          int createNewApplicationInstance(int custOrgID, int applicationID)
        %                 Effect: Creates a new ApplicationInstance for an application for a customer organisation and returns its id.
        %                 \item Created for: UC19.4, U2 - easy applications
        %
        %     5. The system checks which topology configuration and selection of pluggable devices for the application are necessary
        %        (e.g., to indicate in which rooms a heating control application should run)
        %        and presents a topology allowing the primary actor to indicate their configuration.
        %             CustomerOrganisationFacade -> ApplicationManager: interface FrontEndAppMgmt:         List<RoomTopology> getNecessaryDevicesAndTopologyConfigurations(int applicationID)
        %                 Effect: Returns a list of RoomTopology which is a minimal requirement for a certain application to run. This can used to display the requirements to a user or to check if requirements are fulfilled.
        %                 \item Created for: UC19.5, U2 - easy applications
        %             ApplicationManager -> OtherDataDB:                interface AppMgmt:      List<RoomTopology> getNecessaryDevicesAndTopologyConfigurations(int applicationID)
        %                 Effect: Returns a list of RoomTopology which is a minimal requirement for a certain application to run. This can used to display the requirements to a user or to check if requirements are fulfilled.
        %                 \item Created for: UC19.5, U2 - easy applications
        %             CustomerOrganisationFacade -> TopologyManager:    interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID)
        %                 Effect: Returns a list of RoomTopology associated to a customer organisation.
        %                 \item Created for: UC19.5, U2 - easy applications
        %             TopologyManager -> DeviceDB:                      interface TopologyMgmt: List<RoomTopology> getTopology(int custOrgID)
        %                 Effect: Returns a list of RoomTopology associated to a customer organisation.
        %                 \item Created for: UC19.5, U2 - easy applications
        %
        %     6. The primary actor carries out the topology configuration.
        %             // update the topology settings for the ApplicationInstance = which devices the application will use for different things + relationships between the devices
        %             CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: void updateApplicationDevicesSettings(int applicationInstanceID, List<PluggableDeviceID> devices, List<Relationships> relationships)
        %                 Effect: Updates an ApplicationInstance's device settings. This includes which devices the instance can use and which relationships exist between those devices.
        %                 \item Created for: UC19.6, U2 - easy applications
        %             CustomerOrganisationFacade -> ApplicationManager:         interface FrontEndAppMgmt:             void updateApplicationDevicesSettings(int applicationInstanceID, List<PluggableDeviceID> devices, List<Relationships> relationships)
        %                 Effect: Updates an ApplicationInstance's device settings. This includes which devices the instance can use and which relationships exist between those devices.
        %                 \item Created for: UC19.6, U2 - easy applications
        %             ApplicationManager -> OtherDataDB:                        interface AppMgmt:          void updateApplicationDevicesSettings(int applicationInstanceID, List<PluggableDeviceID> devices, List<Relationships> relationships)
        %                 Effect: Updates an ApplicationInstance's device settings. This includes which devices the instance can use and which relationships exist between those devices.
        %                 \item Created for: UC19.6, U2 - easy applications
        %
        %     7. The system loads the (mandatory and optional) roles to which end-users have to be (or can be) assigned for that application.
        %             CustomerOrganisationFacade -> UserManager: interface RoleMgmt:     List<UserRole> getMandatoryUserRoles(int applicationID)
        %                 Effect: Returns a list of UserRoles that which need to be assigned in order for an ApplicationInstance to run.
        %                 \item Created for: UC19.7, U2 - easy applications
        %             UserManager -> OtherDataDB:                interface UserRoleMgmt: List<UserRole> getMandatoryUserRoles(int applicationID)
        %                 Effect: Returns a list of UserRoles that which need to be assigned in order for an ApplicationInstance to run.
        %                 \item Created for: UC19.7, U2 - easy applications
        %             CustomerOrganisationFacade -> UserManager: interface RoleMgmt:     List<UserRole> getOptionalUserRoles(int applicationID)
        %                 Effect: Returns a list of UserRoles which can optionally be assigned for an ApplicationInstance.
        %                 \item Created for: UC19.7, U2 - easy applications
        %             UserManager -> OtherDataDB:                interface UserRoleMgmt: List<UserRole> getOptionalUserRoles(int applicationID)
        %                 Effect: Returns a list of UserRoles which can optionally be assigned for an ApplicationInstance.
        %                 \item Created for: UC19.7, U2 - easy applications
        %
        %     8. The system loads the end-users associated with the primary actor, presents them to the primary actor, and requests to assign end-users to the roles in the application.
        %             CustomerOrganisationFacade -> UserManager: interface RoleMgmt:     List<User> getEndUsers(int custOrgID)
        %                 Effect: Returns a list of Users which are associated to a customer organisation.
        %                 \item Created for: UC19.8, U2 - easy applications
        %             UserManager -> OtherDataDB:                interface UserRoleMgmt: List<User> getEndUsers(int custOrgID)
        %                 Effect: Returns a list of Users which are associated to a customer organisation.
        %                 \item Created for: UC19.8, U2 - easy applications
        %
        %     9. The primary actor provides end-users for the roles.
        %             CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: void updateUserRoles(int applicationInstanceID, Map<int, int> usersAndRoles)
        %                 Effect: Updates the UserRoles assigned to Users for a certain ApplicationInstance. 'usersAndRoles' maps User IDs to UserRole IDs.
        %                 \item Created for: UC19.9, U2 - easy applications
        %             CustomerOrganisationFacade -> UserManager:           interface RoleMgmt:         void updateUserRoles(int applicationInstanceID, Map<int, int> usersAndRoles)
        %                 Effect: Updates the UserRoles assigned to Users for a certain ApplicationInstance. 'usersAndRoles' maps User IDs to UserRole IDs.
        %                 \item Created for: UC19.9, U2 - easy applications
        %             UserManager -> OtherDataDB:                          interface UserRoleMgmt:     void updateUserRoles(int applicationInstanceID, Map<int, int> usersAndRoles)
        %                 Effect: Updates the UserRoles assigned to Users for a certain ApplicationInstance. 'usersAndRoles' maps User IDs to UserRole IDs.
        %                 \item Created for: UC19.9, U2 - easy applications
        %
        %     10. The system asks the primary actor if this application should be considered a critical application (cf. P2 : Requests to the pluggable data database).
        %             CustomerOrganisationClient moves to the next page = form asking for criticality of app
        %
        %     11. The primary actor indicates the criticality of the application. TODO update descriptions
        %             CustomerOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt: void createSubscription(int custOrgID, int applicationInstanceID, bool isCritical)
        %                 Effect: Updates the criticality of an ApplicationInstance.
        %                 \item Created for: UC19.11, U2 - easy applications
        %
        %     12. The system registers the subscription and criticality of the application.
        %             CustomerOrganisationFacade -> SubscriptionManager:        interface SubscriptionMgmt: void createSubscription(int custOrgID, int applicationInstanceID,bool isCritical)
        %                 Effect: Creates a subscription for a customer organisation to an ApplicationInstance. If the customer organisation is already subscribed to an older version of the the application, then the organisation is unsubscribed from that earlier version.
        %                 \item Created for: UC19.12-13, U2 - easy applications
        %             SubscriptionManager -> OtherDataDB:                       interface SubscriptionMgmt: void createSubscription(int custOrgID, int applicationInstanceID)
        %                 Effect: Creates a subscription for a customer organisation to an ApplicationInstance. If the customer organisation is already subscribed to an older version of the the application, then the organisation is unsubscribed from that earlier version.
        %                 \item Created for: UC19.12-13, U2 - easy applications
        %             CustomerOrganisationFacade -> ApplicationManager:         interface FrontEndAppMgmt:             void updateCriticality(int applicationInstanceID, bool isCritical)
        %                 Effect: Updates the criticality of an ApplicationInstance.
        %                 \item Created for: UC19.11, U2 - easy applications
        %             ApplicationManager -> OtherDataDB:                        interface AppMgmt:          void updateCriticality(int applicationInstanceID, bool isCritical)
        %                 Effect: Updates the criticality of an ApplicationInstance.
        %                 \item Created for: UC19.11, U2 - easy applications
        %
        %     13. If the selected application is a newer version of an application to which the primary actor was previously subscribed,
        %         the primary actor is automatically unsubscribed from that earlier version (cf. step 4 or UC20 : Unsubscribe from application).
        %             See step 12 method createSubscription
        %
        %     14. The system activates the application (Include: UC17 : Activate an application).
        %             CustomerOrganisationFacade -> ApplicationManager: interface FrontEndAppMgmt: void activateApplication(int applicationInstanceID)
        %                 Effect: Activates an ApplicationInstance.
        %                 \item Created for: UC19.14, U2 - easy applications

\subsection{Instantiation and allocation of functionality}
    This section lists the new components which instantiate our solutions
    described in the section above. For each component we note the quality
    attribute or use case that prompted us to create it. Descriptions about
    the components can be found under chapter \ref{ch:elements-datatypes}. \\

    \begin{itemize}
        \item AccessRightsManager: U2, UC9
        \item ApplicationContainerManager: U2, UC17
        \item CustomerOrganisationClient: U2, UC19
        \item CustomerOrganisationFacade: U2, UC19
        \item DeviceDB: U2, UC4, UC6
        \item InfrastructureOwnerClient: U2, UC9
        \item InfrastructureOwnerFacade: U2, UC9
        \item InfrastructureOwnerManager: U2, UC9
        \item InvoiceManager: U2, UC17
        \item TopologyManager: U2, UC4, UC6, UC17
        \item SubscriptionManager: U2, UC19
        \item UserManager: U2, UC17, UC19
    \end{itemize}


\subsection{Interfaces for child modules}
    This section lists new interfaces assigned to the components defined
    in the section above. Detailed information about each interface and
    its methods can be found under chapter \ref{ch:elements-datatypes}.

    \subsubsection{AccessRightsManager}
        \begin{itemize}
            \item AccessRightsMgmt
        \end{itemize}

    \subsubsection{ApplicationContainerManager}
        \begin{itemize}
            \item AppMgmt
        \end{itemize}

    \subsubsection{ApplicationManager}
        \begin{itemize}
            \item FrontEndAppMgmt
            \item IOAppMgmt
        \end{itemize}

    \subsubsection{CustomerOrganisationFacade}
        \begin{itemize}
            \item SubscriptionMgmt
        \end{itemize}

    \subsubsection{DeviceDB}
        \begin{itemize}
            \item AccessRightsMgmt
            \item DeviceMgmt
            \item TopologyMgmt
            \item IODeviceMgmt
        \end{itemize}

    \subsubsection{InfrastructureOwnerFacade}
        \begin{itemize}
            \item AccessRights
        \end{itemize}

    \subsubsection{InfrastructureOwnerManager}
        \begin{itemize}
            \item IOMgmt
        \end{itemize}

    \subsubsection{InvoiceManager}
        \begin{itemize}
            \item InvoiceMgmt
        \end{itemize}

    \subsubsection{OtherDataDB}
        \begin{itemize}
            \item InvoiceMgmt
            \item IOMgmt
            \item SubscriptionMgmt
            \item UserRoleMgmt
        \end{itemize}

    \subsubsection{TopologyManager}
        \begin{itemize}
            \item TopologyMgmt
        \end{itemize}

    \subsubsection{SubscriptionManager}
        \begin{itemize}
            \item SubscriptionMgmt
        \end{itemize}

    \subsubsection{UserManager}
        \begin{itemize}
            \item RoleMgmt
        \end{itemize}


\subsection{New data types}
    This section lists the new data types introduced during this decomposition.

    \begin{itemize}
        \item Application
        \item IPAddress
        \item Relationship
        \item RoomTopology
        \item User
        \item UserRole
    \end{itemize}
