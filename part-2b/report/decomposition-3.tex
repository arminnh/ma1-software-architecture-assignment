\section{Decomposition 3: U2, UC4, UC6, UC9, UC10, UC17, UC19.7-11}

\subsection{Elements/Subsystem to decompose/expand}
    In this run we decompose/expand ...


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{U2}: Easy installation
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC4}: Install mote \\
              Short description
        \item \emph{UC6}: Insert a pluggable device into a mote \\
              Short description
        \item \emph{UC9}: Configure pluggable device access rights \\
              Short description
        \item \emph{UC10}: Consult and configure topology \\
              Short description
        \item \emph{UC17}: Activate an application \\
              Short description
        \item \emph{UC19}: Subscribe to application \\
              Short description
    \end{itemize}


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    topology
        gateways(id, floor, room_number, wall, status)
        motes(id, gateway_id, floor, room_number, status)
        pluggable_devices(id, mote_id, gateway_id, status, physical location)
        pluggable_devices_redundancies(deviceID1, deviceID2)

    access rights
        rights(id, origranisation_id, device_id, can_read, can_configure, can_send_actuation_command)

    \paragraph{U2: Gateway installation}
        The gateway should not require any configuration, other than being connected
        to the local wired or WiFi network, after it is plugged into an electrical
        socket. An infrastructure owner should be able get the SIoTIP gateway
        up-and-running (connected) within 10 minutes given that the information
        (e.g. WiFi SSID and passphrase) is available to the person responsible for
        the installation. \\
        TODO: ask \\
        We need something that registers the gateway automatically with the
        online service after bootup. A connection to the internet is a constraint
        of the GatewayFacade.

    \paragraph{U2: Mote installation}
        Installing a new mote should not require more configuration than adding it
        to the topology. Adding new motes, sensors or actuators should not involve
        more than just starting motes, and plugging devices into motes – plug-and-play! TODO: ask \\
        Reintroducing a previously known mote, with the same pluggable devices attached to it,
        should not require any configuration. It is automatically re-added on
        its last known location on the topology. The attached pluggable devices
        are automatically initialised and configured with their last known
        configuration and access rights. \\
        Thing that need to happen automatically:
        *) mote should find the gateway (mote sends a broadcast message->ReceiveBroadcast)
        *) gateway should register the mote (DeviceManager update, store entry in DB)
        *) on reintroduction of motes: DeviceManager notices this, makes the gateway send a message to online service to reuse some old topology

        UC4:
            Remark : The mote is pre-congured to connect to a specic gateway by
             the hardware manufacturer. This linking process is out of scope for
             this assignment. Likewise, the automatic assignment of an IPv6 address
             to the mote is out of scope.

            if new mote:
                for step 2., we can use the heartbeat system. heartbeat is sent from mote to gateway,
                the DeviceManager in the gateway notices that this is from a new mote and starts
                the registerMote procedure
                FOR RATIONALE: The IPAddress of the mote can be parsed out of the 6lowpan header in the heartbeat messages
                ALTERNATIVE IS GatewayFacade: registerMote, but this is more work (battery power and implementation)
                % DONT NEED THIS ONE 2. MoteFacade -> GatewayFacade: registerMote(moteID, IPAddress moteIPAddress)
                % ALSO DONT NEED THIS ONE 3. GatewayFacade -> DeviceManager: registerMote(moteID, IPAddress moteIPAddress)
                % 3. DeviceManager -> GatewayFacade -> PluggableDeviceDataScheduler: addMote(moteID, gatewayID, IPAddress moteIPAddress)
                                                    %  PluggableDeviceDataScheduler -> PluggableDeviceDB: addMote(moteID, gatewayID, IPAddress moteIPAddress)
                                                %   -> TopologyManager: addMote(infrastructureOwnerID, gatewayID, moteID) // status = unplaced
                                                    %  TopologyManager -> PluggableDeviceDataScheduler -> PluggableDeviceDB: addMoteInTopology(infrastructureOwnerID, gatewayID, moteID)
                % 4. DeviceManager -> GatewayFacade -> NotificationHandler: notify(infrastructureOwnerID, message)

        if reintroduced mote:
            It is automatically re-added on its last known location on the topology.
                % 3. DeviceManager -> GatewayFacade -> PluggableDeviceDataScheduler: reactivateMote(moteID)
                % 3. DeviceManager -> GatewayFacade -> TopologyManager: reactivateMote(moteID) // status = placed? (TODO ASK?), location is still there from the past, it was not removed

            The attached pluggable devices are automatically initialised and configured with their last known configuration.
            The attached pluggable devices are automatically initialised and configured with their last known access rights.
                Already done by DeviceManager, it detects the devices, updates DB, and configures the devices
                % 3. DeviceManager -> GatewayFacade -> PluggableDeviceDataScheduler: reactivateDevice(deviceID)


    \paragraph{U2: Pluggable device installation}
        Adding new sensors or actuators should require no further customer
        actions besides plugging it into the mote. Configurable sensors and
        actuators should have a working default configuration.
        Pluggable devices added to an already known mote are automatically
        added in the right location on the topology.
        Making (initialised) sensors and actuators available to customer
        organisations and applications should not require more effort than
        configuring access rights (cf. UC9). \\
        *) After devices are plugged in: connect to mote, set up default configurations
        *) if the mote is already known, the device is added to the right location on the topology
        *) need something for configuration of access rights, can only happen for initialised devices

        *) for reactivating last configurations: just set status to active and don't change configuration field, it will still be the same as in the past
            alternative: current_configuration and last_configuration in DB
            alternative: store all configurations on Gateway -> but it has bad resources
            alternative: store all versions on PluggableDeviceDB -> but lots of useless data then = extra work for db

        *) Pluggable devices added to an already known mote are automatically added in "the right location" on the topology.
            what exactly is a location?
            => when a pluggable device is connected to a new mote, the pluggable device gets the location of the mote by default

        UC6: insert a pluggable device into a mote
            mote is already installed

            when device is plugged into a mote:
                mote -> DeviceManager: registerDevice(id, type) (registers device as uninitialised)
                DeviceManager -> PluggableDeviceDatabase: addDevice(id, type, status) (status = uninitialised)
                DeviceManager -> TopologyManager: addDeviceToMote(deviceID, moteID, status) (status = unplaced) (sets the location to the same of the mote)
                DeviceManager -> NotificationHandler: newPluggableDevice

                In these methods, if the device already exists and is plugged in in another mote, clear the data

            if the device is a known previously active device (ON THE SAME MOTE):
                mote -> DeviceManager: registerDevice(id, type)

                ∗ marks the pluggable device as ‘active’: DB pluggable_devices
                    DeviceManager -> PluggableDeviceDataScheduler: reactivateDevice(deviceID)

                ∗ updates the topology: DB topology_pluggable_devices
                    DeviceManager -> TopologyManager: reactivateDevice(deviceID)

                ∗ configures the pluggable device with the last known access rights: DB permissions_pluggable_devices
                    % DeviceManager -> DeviceAccessRightsManager: reactivate(deviceID)
                    nothing needs to happen here, permission information will just not be used if the device is inactive
                                                  if the device is reactivated, the permissions are already there

                * configures the pluggable device with the last known configuration: DB pluggable_devices
                    DeviceManager -> PluggableDevice: setConfiguration(Map<String, String> lastKnownConfiguratoin) (lastKnown.. taken from DB)

                ∗ checks and activates applications which can now execute again:
                    DeviceManager -> ApplicationManager: checkPluggableDevices() something like this

                * send notification
                    DeviceManager -> NotificationHandler: reactivatedPluggableDevice

        UC9: configure pluggable device access rights
            1. InfrastructureOwnerClient -> InfrastructureOwnerFacade: getAccessRights()
                2. InfrastructureOwnerFacade -> DeviceManager: getPluggableDevices(infrastructureOwnerID)
                3. InfrastructureOwnerFacade -> AccessRightsManager: getAccessRights(pluggableDeviceID)
                4. InfrastructureOwnerFacade -> OtherFunctionality: getCustomerOrganisations(infrastructureOwnerID)
            6. InfrastructureOwnerClient -> InfrastructureOwnerFacade: setAccessRights/updateAccessRights(pluggableDeviceID, List<int> customerOrganisations)
                6. InfrastructureOwnerFacade -> DeviceManager: configureAccessRights(pluggableDeviceID, List<int> customerOrganisations)
                7.a. AccessRightsManager -> PluggableDeviceDatabase: updateDeviceAccessRights(deviceID, custOrg) / deleteAccessRights()
                7.b. AccessRightsManager -> ApplicationManager: checkAccessRights(custOrg)
                7.c. AccessRightsManager -> ApplicationManager: checkPluggableDevices(custOrg)


    \paragraph{U2: Easy applications}
        Applications should work out of the box if the required sensors and
        actuators are available. Only when mandatory end-user roles must be
        assigned, additional explicit configuration actions are required
        from a customer organisation (cf. UC17, UC19). \\
        *) if there is a subsription and new hardware is plugged in: need something to check
           if some application can be activated now
        *) need something to assign user roles to users during UC19

        UC17:
            application needs to be activated because new subscription, changed topology, new version of application

            ApplicationManager is triggered by something else do to the following: method activateApplication(applicationInstanceID)
            1. ApplicationManager -> UserRolesManager: checkMandatoryUserRoles(applicationInstanceID)
            2. ApplicationManager -> DeviceManager: checkPluggableDevices(applicationInstanceID)
            3. ApplicationManager -> GatewayFacade: activateApplication(applicationInstanceID) -> ApplicationSandbox component on gateway
            4. application.start();
            4. ApplicationManager -> InvoiceManager: activatedApplication(applicationInstanceID, custOrgID, date)
            5. ApplicationManager -> NotificationManager: activatedApplication(custOrgID)
            6. ApplicationManager -> UserRolesManager: List<User> getUsersWithRoles(custOrgID)
            6. ApplicationManager -> getInstallationInstructions(applicationID)
            6. ApplicationManager -> NotificationManager: notify(userID, message)

            TODO notifications for alternative scenario's

        UC19:
            2. CustomerOrganisationClient -> CustomerOrganisationFacade: List<Application> getApplicationsToSubscribe(custOrgID)
                   CustomerOrganisationFacade -> ApplicationManager: List<Application> getApplicationsToSubscribe(custOrgID)
            4. CustomerOrganisationClient -> CustomerOrganisationFacade: subscribeToApplication(custOrgID, applicationID)
            5. CustomerOrganisationFacade -> ApplicationManager: getMandatoryDevicesAndTopologyConfigurations(applicationID)
            6. TODO: The primary actor carries out the topology configuration ??????????????????????????????????????????????????????????????????????????????????
            7. CustomerOrganisationFacade -> ApplicationManager: getAllUserRoles(applicationID)
            8. CustomerOrganisationFacade -> UserRolesManager: getAllUsers(custOrgID)
            9. CustomerOrganisationClient -> CustomerOrganisationFacade: setUserRoles(custOrgID, map<String, String> userRoles)
                   CustomerOrganisationFacade -> UserRolesManager: setUserRoles(custOrgID, map<String, String> userRoles)
                   10. <- return value is next page for selection of criticality
            11. CustomerOrganisationClient -> CustomerOrganisationFacade: setCriticality(applicationID, bool isCritical)
                    12. CustomerOrganisationFacade -> ApplicationManager: setCriticality(applicationID, bool isCritical)
            13. CustomerOrganisationFacade -> SubscriptionManager: subscribe(customerOrganisationID, applicationID) // returns applicationInstanceID of new application instance, if the org is subscribed to a older version, automatically unsubscribe
            14. CustomerOrganisationFacade -> ApplicationManager: activateApplication(applicationInstanceID)


\subsection{Instantiation and allocation of functionality}
    This section describes the new components which instantiate our solutions described
    in the section above and how components are deployed on physical nodes. \\
    Unless stated otherwise the responsibilities assigned in the first decomposition are unchanged.

    \paragraph{Decomposition}
        Figure \ref{fig:FIGURELABEL} shows the components resulting from the
        decomposition in this run.

        \begin{figure}[!h]
        	\centering
            %\includegraphics[width=1\textwidth]{IMAGE FILE NAME}
        	\missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram of this decomposition}
        	\caption{Component-and-connector diagram of this decomposition.}
            \label{fig:FIGURELABEL}
        \end{figure}

        The responsibilities of the components are as follows:

    \subparagraph{Component}
        Short description of its responsibilities. (Relevant QA or UC)


    % \paragraph{Behaviour}
        % USEFUL SEQUENCE DIAGRAMS FOR CHOSEN USE CASES


    \paragraph{Deployment}
        Figure \ref{fig:FIGURELABEL} shows the allocation of components
        to physical nodes.

        \begin{figure}[!h]
        	\centering
        	%\includegraphics[width=0.8\textwidth]{IMAGE FILE NAME}
        	\missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
        	\caption{Deployment diagram of this decomposition.}
            \label{fig:FIGURELABEL}
        \end{figure}


\subsection{Interfaces for child modules}\label{add2-interfaces}
    This section describes the interfaces assigned to the components defined
    in the section above. Per interface, we list its methods by means of its
    syntax. The data types used in these interfaces are defined in the following section. \\

    Each method shows which (part of a) quality attribute or use case caused
    a need for the method. However, this does not mean that a method is
    only to be used to satisfy that quality  attribute or use case, it could
    be used for other causes not yet mentioned here.

    The interfaces and methods defined here are to be seen as an
    extension of the interfaces defined in previous sections, unless
    explicitly stated otherwise.

    \subsubsection{DeviceDataScheduler}
        \begin{itemize}
            \item DeviceMgmt
            \begin{itemize}
                \item \texttt{void addMote(int moteID, int gatewayID, IPAddress moteIPAddress)}
                    \begin{itemize}
                        \item Effect:
                        \item Created for: UC4.3
                    \end{itemize}
                \item \texttt{void reactivateMote(int moteID)}
                    \begin{itemize}
                        \item Effect:
                        \item Created for: UC4.3
                    \end{itemize}
            \end{itemize}

        	\item TopologyMgmt
        	\begin{itemize}
        		\item \texttt{void addMoteInTopology(int infrastructureOwnerID, int gatewayID, int moteID)}
        		\begin{itemize}
        			\item Effect:
        			\item Created for: UC4.3
        		\end{itemize}

                \item \texttt{void reactivateMoteInTopology(int moteID)}
                \begin{itemize}
                    \item Effect: Sets status to placed.
                    \item Created for: UC4.3
                \end{itemize}
        	\end{itemize}
        \end{itemize}

    \subsubsection{GatewayFacade}
        \begin{itemize}
            \item DeviceMgmt, last defined in section \ref{add1-interfaces}
            \begin{itemize}
                \item \texttt{void addMote(moteID, int gatewayID, IPAddress moteIPAddress)}
                \begin{itemize}
                    \item Effect:
                    \item Created for: UC11: UC4.3
                \end{itemize}
                \item \texttt{void reactivateMote(int moteID)}
                \begin{itemize}
                    \item Effect: Uses the DeviceDataScheduler to change the status of the mote to active.
                          Uses the TopologyManager to change the status of the mote to placed again.
                          Uses the NotificationHandler to send a notification of this event to the infrastructure owner.
                    \item Created for: UC4.3 - reintroduced mote
                \end{itemize}
            \end{itemize}
        \end{itemize}

    \subsubsection{PluggableDeviceDB}
        \begin{itemize}
        	\item DeviceMgmt
        	\begin{itemize}
        		\item \texttt{void addMote(int moteID, int gatewayID, IPAddress moteIPAddress)}
        		\begin{itemize}
        			\item Effect:
        			\item Created for: UC4.3
        		\end{itemize}
                \item \texttt{void reactivateMote(int moteID)}
                    \begin{itemize}
                        \item Effect:
                        \item Created for: UC4.3
                    \end{itemize}
        	\end{itemize}

        	\item TopologyMgmt
        	\begin{itemize}
        		\item \texttt{void addMoteInTopology(int infrastructureOwnerID, int gatewayID, int moteID)}
        		\begin{itemize}
        			\item Effect:
        			\item Created for: UC4.3
        		\end{itemize}
                \item \texttt{void reactivateMoteInTopology(int moteID)}
                    \begin{itemize}
                        \item Effect: Sets status to placed.
                        \item Created for: UC4.3
                    \end{itemize}
        	\end{itemize}

        \end{itemize}

    \subsubsection{TopologyManager}
        \begin{itemize}
        	\item TopologyMgmt
        	\begin{itemize}
        		\item \texttt{void addMote(infrastructureOwnerID, int gatewayID, int moteID)}
        		\begin{itemize}
        			\item Effect: // status = unplaced
        			\item Created for: UC4.3
        		\end{itemize}
                \item \texttt{void reactivateMote(int moteID)}
                    \begin{itemize}
                        \item Effect:
                        \item Created for: UC4.3
                    \end{itemize}
        	\end{itemize}
        \end{itemize}

\subsection{Data type definitions}
    This section defines new data types that are used in the interface descriptions above.

    \paragraph{DataType}
        Description of data type
