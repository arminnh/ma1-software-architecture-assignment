\section{Decomposition 6: P1, UC1, UC2, UC3, UC5, UC7, UC8, UC16, UC20 (Elements/Subsystem to decompose/expand)}


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{P1}: Large number of users
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC1}: Register a customer organisation \\
        \item \emph{UC2}: Register an end-user \\
        \item \emph{UC3}: Unregister an end-user \\
        \item \emph{UC5}: Uninstall mote \\
        \item \emph{UC7}: Remove a pluggable device from its mote \\
        \item \emph{UC8}: Initialise a pluggable device \\
        \item \emph{UC16}: Consult notification message \\
        \item \emph{UC20}: Unsubscribe from application \\
    \end{itemize}


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    https://www.alertra.com/blog/2010/improve-availability-performance-using-database-replication
    https://serverfault.com/questions/10781/what-are-the-performance-implications-for-using-sql-server-replication
    "
    Ik dacht aan misschien de meeste van de componenten gewoon duplicaten maar dan is de DB wel u bottleneck en dan moet ge zo'n systeem van distributed systems gebruiken om ook de databases juist te kunnen replicaten.
    Maar daarnaast echt geen idee ivm performance. Ge kunt wel bullshit van de "tactics" in u rationale zetten zoals the developers have to "increase computation efficiency" and "reduce computational overhead".
    Manage event rate en scheduling policy kunt ge misschien wel gebruiken om er voor te zorgen dat bepaalde taken gebeuren op een moment dat de load op de online service wat lager is maar ik weet Ni echt welke taken
    "

    *) Most components can be duplicated for load balancing
    *) Related DB's should use a DBMS that can be scaled horizontally.
    *) DB calls caused by IO vs CO have been mostly split up in DeviceDB and OtherDataDB, so those 2 groups of
       users don't influence each other too much


    \paragraph{P1: Problem title}
        The SIoTIP Online Service replies to the service requests of the
        infrastructure owner and customer organisations.

    \paragraph{P1: Problem title}
        The Online Service processes the data received from the gateways.

    \paragraph{P1: Problem title}
        The application execution subsystem should be able to execute an increasing
        number of active applications.

    \paragraph{P1: Problem title}
        The initial deployment of SIoTIP should be able to deal with at least 5000
        gateways in total, and should be provisioned to service at least 3000
        registered users simultaneously connected to SIoTIP.
        -> 5000 gateways * 4 motes per gateway * 3 devices per mote = 60000 devices
        -> Keep communication with gateways at a minimum
           e.g. gateway messages are of type "send data", "new device connected", ...
        -> LOAD BALANCING

    \paragraph{P1: Problem title}
        Scaling up to service an increasing amount of infrastructure owners,
        customers organisations and applications should (in worst case) be linear ;
        i.e. it should not require proportionally more resources (machines, etc.)
        than the initial amount of resources provisioned per customer
        organisation/infrastructure owner and per gateway.


    UC1:
        1. The primary actor requests the (infrastructure owner-specific) registration form.
            UnregisteredUserClient -> UnregisteredUserFacade: interface Registration: boolean getRequestForRegistration(int infrastructureOwnerID, string randomHash)
                Effect: Returns true if the infrastructure owner with infrastructureOwnerID exists.
                \item Created for: UC1.1

            UnregisteredUserFacade -> UserManager: interface UserMgmt: boolean infrastructureOwnerExists(int infrastructureOwnerID)
                Effect: Returns true if the infrastructure owner with infrastructureOwnerID exists.
                \item Created for: UC1.1

            UserManager -> OtherDataDB: interface UserMgmt: boolean infrastructureOwnerExists(int infrastructureOwnerID)
                Effect: Returns true if the infrastructure owner with infrastructureOwnerID exists.
                \item Created for: UC1.1

        2. The system asks the primary actor for an e-mail address.

        3. The primary actor enters a company e-mail address.

            UnregisteredUserClient -> UnregisteredUserFacade: interface Registration: boolean enterEmailForRegistration(string emailAddress, int infrastructureOwnerID)
                Effect: Returns true if e-mail address is valid and if a confirmation e-mail was sent to the entered e-mail address.
                \item Created for: UC1.3-4

       4. The system verifies the provided e-mail address, and if the e-mail address is valid, the system
          informs the primary actor that a confirmation e-mail was sent to the entered e-mail address
          with further instructions.

            UnregisteredUserFacade -> UnregisteredUserManager: interface Registration: boolean checkEmail(string emailAddress, int infrastructureOwnerID)
                Effect: Returns true if e-mail adrress is valid and sends confirmation e-mail. TODO
                Exceptions: EmailAddressAlreadyExistsException, EmailAddressInvalidException
                \item Created for: UC1.4

            UnregisteredUserManager -> OtherDataDB: interface Registration: boolean createEmailAddress(string emailAddress, int infrastructureOwnerID)
                Effect: If the given e-mail address is valid and not yet in the database, saves the e-mail address
                        in the database, links it to the infrastructure owner, a unique random string for the confirmation e-mail,
                        and the current timestamp. Then, returns true. \\
                        Otherwise, returns false.
                Exceptions: EmailAddressAlreadyExistsException, EmailAddressInvalidException
                \item Created for: UC1.4

        5. The primary actor confirms his or her e-mail address by following the link in the received e-mail.

            UnregisteredUserClient -> UnregisteredUserFacade: interface Registration: boolean confirmEmail(string emailAddress, string randomString)
                Effect: Return true if the given e-mail and randomString match in the database. \\
                        Returns false if user did not click the link in the received e-mail within 30 minutes.
                \item Created for: UC1.5

            UnregisteredUserFacade -> UnregisteredUserManager: interface Registration: boolean confirmEmail(string emailAddress, string randomString)
                Effect: Return true if the given e-mail and randomString match in the database. \\
                        Returns false if user did not click the link in the received e-mail within 30 minutes.
                \item Created for: UC1.5

            UnregisteredUserManager -> OtherDataDB: interface Registration: boolean checkEmail(string emailAddress, string randomString)
                Effect: Return true if the given e-mail and randomString match in the database. \\
                        Returns false if user did not click the link in the received e-mail within 30 minutes.
                \item Created for: UC1.5

        6. The system asks the primary actor for the remaining information:
           (a) Credentials (e.g., unique username and password)
           (b) Full name of the company and primary address
           (c) Billing and payment information (e.g. credit card information or bank account number,
               and, optionally, invoicing address)
           (d) Contact phone number
           (e) Notification preferences: SMS and/or e-mail.

        7. The primary actor provides the requested information.
            UnregisteredUserClient -> UnregisteredUserFacade: interface Registration: int createCustomerOrganisation(Map<string, string> data)
                Effect: Creates a customer organisation and returns its id.
                Exception: UserNameAlreadyExistsException, AddressInvalidException, PaymentInformationInvalidException
                \item Created for: UC1.7

        8. The system verifies the provided information, and, if the provided information is correct, the
           system creates a new customer organisation profile.

            UnregisteredUserFacade -> UnregisteredUserManager: interface Registration: int createCustomerOrganisation(Map<string, string> data)
                Effect: Creates a customer organisation and returns its id.
                Exception: UserNameAlreadyExistsException, AddressInvalidException, PaymentInformationInvalidException
                \item Created for: UC1.8

            UnregisteredUserManager -> OtherDataDB: interface Registration: int createCustomerOrganisation(Map<string, string> data)
                Effect: Creates a customer organisation and returns its id.
                Exception: UserNameAlreadyExistsException, AddressInvalidException, PaymentInformationInvalidException
                \item Created for: UC1.8

        9. The system notifies the primary actor that the registration is successful.
            => return value of step 7

        TODO: check if linked to IO


    UC2:
        1. The primary actor indicates to the system that he or she wants to register an end-user.
            IN CustomerOrganisationClient

        2. The system asks the primary actor for details about the end-user to be registered:
           Name, Phone number (for SMS) and/or e-mail address
           IN CustomerOrganisationClient

        3. The primary actor supplies the requested information.
            CustomerOrganisationClient -> CustomerOrganisationFacade: interface UserMgmt: boolean createEndUser(int customerOrganisationID, Map<string, string> data)
                Effect: Verifies provided data for a new end-user, checks that the end-user does not exist in the system already, and then stores the end-user information
                        and associates it with the customer organisation. Returns true if everything succeeded.
                Exception: EmailAddressAlreadyExistsException, EmailAddressInvalidException, PhoneNumberInvalidException, EndUserAlreadyExistsException
                \item Created for: UC2.3-4

        4. The system verifies the provided e-mail address or phone number, and checks that the end-user
            does not exist in the system already. If the provided information is valid, the system stores
            the end-user information and associates it with the primary actor.

            CustomerOrganisationFacade -> UserManager: interface UserMgmt: boolean createEndUser(int customerOrganisationID, Map<string, string> data)
                Effect: Verifies provided data for a new end-user, checks that the end-user does not exist in the system already, and then stores the end-user information
                        and associates it with the customer organisation. Returns true if everything succeeded.
                Exception: EmailAddressAlreadyExistsException, EmailAddressInvalidException, PhoneNumberInvalidException, EndUserAlreadyExistsException
                \item Created for: UC2.3-4

            UserManager -> OtherDataDB: interface UserMgmt: boolean createEndUser(int customerOrganisationID, Map<string, string> data)
                Effect: Verifies provided data for a new end-user, checks that the end-user does not exist in the system already, and then stores the end-user information
                        and associates it with the customer organisation. Returns true if everything succeeded.
                Exception: EmailAddressAlreadyExistsException, EmailAddressInvalidException, PhoneNumberInvalidException, EndUserAlreadyExistsException
                \item Created for: UC2.3-4

        5. The system informs the primary actor that the end-user was registered successfully.
            => return value of createEndUser

    UC3:
        1. The primary actor indicates to the system that they want to unregister an end-user.
            CustomerOrganisationClient -> CustomerOrganisationFacade: interface EndUserMgmt
                                            void uncreateEndUser()
            Effect: unregister end-user
            \item Created for: UC3.1
        2. The system retrieves all end-users associated with the primary actor and presents this list to
            the primary actor.
            CustomerOrganisationFacade -> UserManager: interface UserMgmt:
                                                void getRelatedEndUsers(int custOrgID)
            Effect: Customer organisation has a list of all related end-users
            \item Created for: UC3.2

        3. The primary actor indicates which end-user she wants to unregister.
             CustomerOrganisationFacade -> UserManager: interface UserMgmt:
                                                void uncreateEndUser(int endUserID)

            Effect: unregister end-user
            \item Created for: UC3.3

        4. The system marks the profile of the end-user as `inactive'
            UserManager -> OtherDataDb: interface UserUserMgmt:
                                                void uncreateEndUser(int endUserID)
            Effect: sets end-user as 'inactive'
            \item Created for UC3.4

        5. The system checks if any applications should be deactivated because of end-user assignment
            to mandatory roles (Include: UC18: Check and deactivate applications).
            UserManager -> ApplicationManager: interface ??? UC18
        6. The system informs the primary actor that the end-user is now unregistered from SIoTIP.
            Notify()

    UC5:
        1. The primary actor physically stops the mote (by unplugging, powering off, or taking it out of
            the vicinity of the network).
        2. When the system no longer receives heartbeat messages,
            Already done: Mote -> DeviceManager: interface Heartbeat

            -it marks the mote as `inactive' in the topology.
            DeviceManager -> OnlineServiceBroker: interface TopologyMgmt deactivateMote(int moteID)
            Effect: sends request for deactivation of mote.
            \item UC5.2a

            -it looks up the pluggable devices that were attached to the affected mote and marks these
                as `inactive' in the topology.
            DeviceManager -> OnlineServiceBroker: interface TopologyMgmt deactivatePluggableDevices(int moteID)
            Effect: sends request for deactivation of pluggable devices related to the mote.
            \item UC5.2b

            OnlineServiceBroker -> GatewayBroker: interface GWCommunication
            sendData()

            GatewayBroker -> ApplicationManager: interface TopologyMgmt: deactivateMote(int moteID)
            GatewayBroker -> ApplicationManager: interface TopologyMgmt: deactivatePluggableDevices(int moteID)

            ApplicationManager -> TopologyManager: interface TopologyMgmt: deactivateMote(int moteID)
            ApplicationManager -> TopologyManager: interface TopologyMgmt: deactivatePluggableDevices(int moteID)

            TopologyManager -> TopologyManager: interface DBTopologyMgmt: deactivateMote(int moteID)
            TopologyManager -> TopologyManager: interface DBTopologyMgmt: deactivatePluggableDevices(int moteID)

            -it checks for and deactivates applications that are affected by the unavailability of the
                pluggable devices (Include: UC18: Check and deactivate applications).
                seeUC18 - we dont have fucntion for deactivate application for pluggable devices, we can create one, or get
                            first list of all apllication related to the pluggable devices, and the go to the Application Manager and
                            call method deactivateApplication(appInstance)

            -It sends a notification to the primary actor (Include: UC15: Send notification).
            notify()



     UC7:
        1. The primary actor unplugs the pluggable device from its mote.
        2. A message is sent from the mote from which the pluggable device was removed to the system,
            containing the identifier of the removed pluggable device.
            Mote -> DeviceManger: interface Heartbeat : find out that pluggable device is not in heartbeat
            DeviceManager -> OnlineServiceBroker: interface TopologyMgmt deactivatePluggableDevices(int moteID)
        3. The system
        { marks the pluggable device as `inactive',
           GatewayBroker -> ApplicationManager: interface TopologyMgmt: deactivatePluggableDevices(int moteID)
        { updates the topology,
           ApplicationManager -> TopologyManager: interface TopologyMgmt: deactivatePluggableDevices(int moteID)
        { it checks and deactivates applications for which the pluggable device was essential
        (Include: UC18: Check and deactivate applications).
        seeUC18 - we dont have fucntion for deactivate application for pluggable devices, we can create one, or get
                            first list of all apllication related to the pluggable devices, and the go to the Application Manager and
                            call method deactivateApplication(appInstance)

     UC8:
        1. The primary actor indicates that they want to initialise the newly attached pluggable for use.
            InfrastructreOwnerClient -> InfrastructreOwnerFacade: interface DeviceMgmt
                                void initialisePluggableDevice()

        2. The system allows the primary actor to configure the pluggable device in the topology
            (Include: UC10: Consult and configure the topology), e.g. to set its physical location.
             See and create UC10
        3. The system marks the pluggable device as `active', and informs the primary actor that the
            pluggable is ready for use.
            InfrastructureOwnerManager -> TopologyManager: interface TopologyMgmt reactivateDevice()

        4. The system allows the primary actor to configure the access rights for the pluggable device
            (Include: UC9: Configure pluggable device access rights).
            See UC9
         Remarks:
            Initializing a new pluggable device may result in `inactive' applications being able to activate
            (cf. UC17: Activate an application) we need to get somehow list of applications that need just this pluggable device

     UC16:
     1. The primary actor indicates that he/she/they wants to consult a notification.
            ApplicationProviderClient/CustomerOrganisationClient/InfrastructureOwnerClient/SysAdminClient -> UserFacade:
                    interface Notifications: void consultNotifications()

     2. The system retrieves all notifications for the primary actor and presents them to the primary
        actor, e.g. as a table or list.
        UserFacade -> NotificationHandler: interface NotificationsMgmt:
                List<Notification> getNotifications(int userID)


     3. The primary actor selects a notification.
            ApplicationProviderClient/CustomerOrganisationClient/InfrastructureOwnerClient/SysAdminClient -> UserFacade:
                                Notification consultNotifications(int notificationID)
            Effect: Returns information about the notification.
            \item Created for: UC16.3



     4. The system presents the details for the selected notification to the primary actor. This includes:
        { A description of the event that occurred.
        { Date and time the event occurred.
        { What triggered the event (e.g., the cause of an application that became inactive)
        { The status of the notification (e.g. `sent', `delivered', `read')
        { The communication channel by which the notification was sent


     5. The system marks the notification as `read'.
     UserFacade -> NotificationHandler: interface NotificationsMgmt:
                List<Notification> setNotificationRead(int notificationID)

     UC20:
        1. The primary actor indicates they want to unsubscribe from an application.
            CustomOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt
                                              void  unsubscribeFromApplications()


        2. The system looks up a list of applications the primary actor is subscribed to, and presents this
            overview to the primary actor, e.g. as a list or table.
            CustomerOrganisationFacade -> ApplicationManager: interface FrontEndAppRequests:
                                             List<int> getApplications(int custOrgID)

        3. The primary actor indicates which application they want to unsubscribe from.
             CustomOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt
                                              void  unsubscribeFromApplication(int applicationInstanceID)
             Effect: Unsubscribes a customer organisation from an application.
             \item Created for: UC20.3

             CustomerOrganisationFacade -> SubscriptionManager: interface SubscriptionMgmt
                                              void  deleteSubscription(int applicationInstanceID, int custOrgID)
             Effect: Unsubscribes a customer organisation from an application.
             \item Created for: UC20.3

        4. The system (i) ends the subscription for the selected application, (ii) deactivates the applica-
            tion, and (iii) constructs an invoice for outstanding payments for that application (cf. UC21:
            Send invoice).

            SubscriptionManager -> OtherDataDB: interface DBSubscriptionMgmt:
                                             void deleteSubscription(int custOrgID, int custOrgID)
                Effect: ends the subscription for the selected application
                \item Created for: UC20.4i

            SubscriptionManager -> ApplicationManager: interface FrontEndAppRequests:
                                    deactivateApplication(int applicationInstanceID, int custOrg)
                Effect: deactivates the application
                \item Created for: UC20.4ii

            ApplicationManager -> OtherDataDB: interface DBAppMgmt:
                                    deactivateApplication(int applicationInstanceID)
                Effect: deactivates the application
                \item Created for: UC20.4ii


            ApplicationManager  -> InvoiceManager: interface InvoiceMgmt
                                   constructInvoice(int applicationInstanceID, int custOrg)
                Effect: deactivates the application
                \item Created for: UC20.4ii


        5. The system informs the primary actor that the unsubscription was successful.
            Notify()

\subsection{Instantiation and allocation of functionality}
    This section lists the new components which instantiate our solutions
    described in the section above. For each component we note the quality
    attribute or use case that prompted us to create it. Descriptions about
    the components can be found under chapter \ref{ch:elements-datatypes}. \\

    \begin{itemize}
        \item UnregisteredUserClient: UC X
              Effect: Represents the client for an unregistered user.
        \item UnregisteredUserFacade: UC X
        \item UnregisteredUserManager: UC X
    \end{itemize}


\subsection{Interfaces for child modules}
    This section lists new interfaces assigned to the components defined
    in the section above. Detailed information about each interface and
    its methods can be found under chapter \ref{ch:elements-datatypes}. \\

    \subsubsection{OtherDataDB}
        \begin{itemize}
            \item Registration
        \end{itemize}
    \subsubsection{UnregisteredUserClient}
        \begin{itemize}
            \item Registration
        \end{itemize}
    \subsubsection{UnregisteredUserFacade}
        \begin{itemize}
            \item Registration
        \end{itemize}
    \subsubsection{CustomerOrganisationFacade}
        \begin{itemize}
            \item EndUserMgmt
        \end{itemize}

\subsection{Data type definitions}
    This section lists the new data types introduced during this decomposition.

    \begin{itemize}
        \item Address: Represents an address of customer organisation.
    \end{itemize}
