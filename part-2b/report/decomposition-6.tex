\section{Decomposition 6: P1, UC1, UC2, UC3, UC5, UC7, UC8, UC16, UC20 (Elements/Subsystem to decompose/expand)}


\subsection{Selected architectural drivers}
    The non-functional drivers for this decomposition are:
    \begin{itemize}
    	\item \emph{P1}: Large number of users
    \end{itemize}

    The related functional drivers are:
    \begin{itemize}
        \item \emph{UC1}: Register a customer organisation \\
        \item \emph{UC2}: Register an end-user \\
        \item \emph{UC3}: Unregister an end-user \\
        \item \emph{UC5}: Uninstall mote \\
        \item \emph{UC7}: Remove a pluggable device from its mote \\
        \item \emph{UC8}: Initialise a pluggable device \\
        \item \emph{UC16}: Consult notification message \\
        \item \emph{UC20}: Unsubscribe from application \\
    \end{itemize}


\subsection{Architectural design}
    This section describes what needs to be done to satisfy the requirements for
    this decomposition and how involved problems/obstacles are solved.

    https://www.alertra.com/blog/2010/improve-availability-performance-using-database-replication
    https://serverfault.com/questions/10781/what-are-the-performance-implications-for-using-sql-server-replication
    "
    Ik dacht aan misschien de meeste van de componenten gewoon duplicaten maar dan is de DB wel u bottleneck en dan moet ge zo'n systeem van distributed systems gebruiken om ook de databases juist te kunnen replicaten.
    Maar daarnaast echt geen idee ivm performance. Ge kunt wel bullshit van de "tactics" in u rationale zetten zoals the developers have to "increase computation efficiency" and "reduce computational overhead".
    Manage event rate en scheduling policy kunt ge misschien wel gebruiken om er voor te zorgen dat bepaalde taken gebeuren op een moment dat de load op de online service wat lager is maar ik weet Ni echt welke taken
    "


    \paragraph{P1: Problem title}
        The SIoTIP Online Service replies to the service requests of the
        infrastructure owner and customer organisations.

    \paragraph{P1: Problem title}
        The Online Service processes the data received from the gateways.

    \paragraph{P1: Problem title}
        The application execution subsystem should be able to execute an increasing
        number of active applications.

    \paragraph{P1: Problem title}
        The initial deployment of SIoTIP should be able to deal with at least 5000
        gateways in total, and should be provisioned to service at least 3000
        registered users simultaneously connected to SIoTIP.
        -> 5000 gateways * 4 motes per gateway * 3 devices per mote = 60000 devices
        -> Keep communication with gateways at a minimum
           e.g. gateway messages are of type "send data", "new device connected", ...
        -> LOAD BALANCING

    \paragraph{P1: Problem title}
        Scaling up to service an increasing amount of infrastructure owners,
        customers organisations and applications should (in worst case) be linear ;
        i.e. it should not require proportionally more resources (machines, etc.)
        than the initial amount of resources provisioned per customer
        organisation/infrastructure owner and per gateway.
        
        
    UC1:
    1. The primary actor requests the (infrastructure owner-specific) registration form.
        UnregisteredUserClient -> UnregisteredUserFacade: interface Registration:
                                         void requestForRegistration(int infrOwnerID)
            Effect: Unregistered user request fo registration for the specific infrastructure owner.
            \item Created for: UC1.1
    2. The system asks the primary actor for an e-mail address.
    3. The primary actor enters a company e-mail address.
        
        UnregisteredUserClient -> UnregisteredUserFacade: interface Registration:
                                         boolean controlEmail(string email,int infrOwnerID)
            Effect: Returns true if email adress is correct and sends confirmation email.
            \item Created for: UC1.3
            
        UnregisteredUserFacade -> UnregisteredUserManager: interface Registration:
                                  boolean controlEmail(string email,int infrOwnerID)
             Effect: Returns true if email adrress is correct.
            \item Created for: UC1.3
            
        UnregisteredUserFacade -> UnregisteredUserManager: interface Registration:
                                  boolean controlEmail(string email, int infrOwnerID)
             Effect: Returns true if email adrress is correct and sends confirmation email.
            \item Created for: UC1.3
            
 
            
   4. The system verifies the provided e-mail address, and if the e-mail address is valid, the system
    informs the primary actor that a confirmation e-mail was sent to the entered e-mail address
    with further instructions.
           UnregisteredUserManager -> OtherDataDB: interface Registration:
                                  boolean controlEmail(string email, int infrOwnerID)
             Effect: Returns true if email address doesnt't exist in database and save email with status "processed" and timestamp.
                     Returns true if email address exists in database.
            \item Created for: UC1.4

    5. The primary actor confirms his or her e-mail address by following the link in the received
    e-mail.
    UnregisteredUserClient -> UnregisteredUserFacade: interface Registration:
                                         boolean confirmEmail(string email)
            Effect: Return true if email was confirmed. Return false if user missed deadline(30 min.)
            \item Created for: UC1.5
        
        UnregisteredUserFacade -> UnregisteredUserManager: interface Registration:
                                   boolean confirmEmail(string email)
             Effect: Return true if email was confirmed. Return false if user missed deadline(30 min.)
            \item Created for: UC1.5
            
        UnregisteredUserManager -> OtherDataDB: interface Registration:
                                  boolean controlEmail(string email, int infrOwnerID)
             Effect: Return true if email was confirmed. Return false if user missed deadline(30 min.)
            \item Created for: UC1.5
    
    6. The system asks the primary actor for the remaining information:
    (a) Credentials (e.g., unique username and password)
    (b) Full name of the company and primary address
    (c) Billing and payment information (e.g. credit card information or bank account number,
        and, optionally, invoicing address)
    (d) Contact phone number
    (e) Notification preferences: SMS and/or e-mail.            
    
    7. The primary actor provides the requested information.
        Map<String,boolean> preferences = type of preference, true/false
     UnregisteredUserClient -> UnregisteredUserFacade: interface Registration:
                                 int saveCustomerOrganisation(string userName, string password, Address adddress, string company, string 
                                 email, string phone, Map<String,boolean> preferences)
            Effect: Returns customer organisation id.
            \item Created for: UC1.7
    
    8. The system verifies the provided information, and, if the provided information is correct, the
    system creates a new customer organisation profile.

            
        UnregisteredUserFacade -> UnregisteredUserManager: interface Registration:
                                  int saveCustomerOrganisation(string userName, string password, Address adddress, string company,string    
                                  email, string phone, Map<String,boolean> preferences)
             Effect: Returns customer organisation id.
            \item Created for: UC1.8
            
            
        UnregisteredUserManager -> OtherDataDB: interface Registration:
                                  int saveCustomerOrganisation(string userName, string password, Address adddress, string company,string    
                                  email, string phone, Map<String,boolean> preferences)
             Effect: Creates new customer organisation, saves information and returns customer organisation id, if information is correct.
             Exception: EmailAlreadyExists
            \item Created for: UC1.8
            
    9. The system notifies the primary actor that the registration is successful.
           
        UnregisteredUserManager -> NotificationHandler: interface Notify 
        
    If the primary actor does not click the link in the received e-mail within 30 minutes, the use
    case is aborted.


    8a. If the chosen user name already exists, the system asks the primary actor for a different user
        name. Continue from step 6.

    8b. If the provided primary company address or invoicing address is not valid, e.g. the provided
        city and postcode do not match, the system asks the primary actor to correct this. Continue
        from step 6.
    8c. If the provided payment information is not correct, e.g. incorrect credit card number, the
        system informs the primary actor of the encountered error. Continue from step 6.
        
    A customer organisation can also be unregistered (triggered by the customer organisation
    itself, or by the associated infrastructure owner). This process involves unsubscribing from all
    applications (cf. UC20: Unsubscribe from application). For simplicity, no explicit use case is
    provided for this scenario.

    UC2: 
        1. The primary actor indicates to the system that he or she wants to register an end-user.
            CustomerOrganisationClient -> CustomerOrganisationFacade: interface EndUserMgmt
                                            void registerEndUser()

        2. The system asks the primary actor for details about the end-user to be registered:
            - Name
            - Phone number (for SMS) and/or e-mail address
       
        3. The primary actor supplies the requested information.
            CustomerOrganisationFacade -> UserRolesManager: interface RoleMgmt:
                                                void registerEndUser(string Name, Map<string,string> contacts)
            Exception: InvalidNumberOrEmailAddress
        4. The system verifies the provided e-mail address or phone number, and checks that the end-user
            does not exist in the system already. If the provided information is valid, the system stores
            the end-user information and associates it with the primary actor.
        
                UserRoleManager -> OtherDataDB: interface UserRoleMgmt:
                                    void registerEndUser(string Name, Map<string,string> contacts)
                Exception: EndUserAlreadyExists
        5. The system informs the primary actor that the end-user was registered successfully.
                Notify()
        
        4a. If the provided phone number or e-mail address is not valid, e.g. badly formatted, or if the
            end-user for which details were provided already exists in the system, the system informs the
            primary actor of this error. Continue from step 2.
        
    UC3: 
        1. The primary actor indicates to the system that they want to unregister an end-user.
            CustomerOrganisationClient -> CustomerOrganisationFacade: interface EndUserMgmt
                                            void unregisterEndUser()
            Effect: unregister end-user
            \item Created for: UC3.1
        2. The system retrieves all end-users associated with the primary actor and presents this list to
            the primary actor.
            CustomerOrganisationFacade -> UserRolesManager: interface RoleMgmt:
                                                void getRelatedEndUsers(int custOrgID)
            Effect: Customer organisation has a list of all related end-users
            \item Created for: UC3.2
            
        3. The primary actor indicates which end-user she wants to unregister.
             CustomerOrganisationFacade -> UserRolesManager: interface RoleMgmt:
                                                void unregisterEndUser(int endUserID)
            
            Effect: unregister end-user
            \item Created for: UC3.3
              
        4. The system marks the profile of the end-user as `inactive'
            UserRolesManager -> OtherDataDb: interface UserRoleMgmt:
                                                void unregisterEndUser(int endUserID)
            Effect: sets end-user as 'inactive' 
            \item Created for UC3.4
               
        5. The system checks if any applications should be deactivated because of end-user assignment
            to mandatory roles (Include: UC18: Check and deactivate applications).
            UserRolesManager -> ApplicationManager: interface ??? UC18
        6. The system informs the primary actor that the end-user is now unregistered from SIoTIP.
            Notify()
            
    UC5:
        1. The primary actor physically stops the mote (by unplugging, powering off, or taking it out of
            the vicinity of the network).
        2. When the system no longer receives heartbeat messages,
            Already done: Mote -> DeviceManager: interface Heartbeat
            
            -it marks the mote as `inactive' in the topology.
            DeviceManager -> OnlineServiceBroker: interface TopologyMgmt deactivateMote(int moteID)
            Effect: sends request for deactivation of mote.
            \item UC5.2a
            
            -it looks up the pluggable devices that were attached to the affected mote and marks these
                as `inactive' in the topology.
            DeviceManager -> OnlineServiceBroker: interface TopologyMgmt deactivatePluggableDevices(int moteID)
            Effect: sends request for deactivation of pluggable devices related to the mote.
            \item UC5.2b
            
            OnlineServiceBroker -> GatewayBroker: interface GWCommunication
            sendData()
            
            GatewayBroker -> ApplicationManager: interface TopologyMgmt: deactivateMote(int moteID)
            GatewayBroker -> ApplicationManager: interface TopologyMgmt: deactivatePluggableDevices(int moteID)
            
            ApplicationManager -> TopologyManager: interface TopologyMgmt: deactivateMote(int moteID)
            ApplicationManager -> TopologyManager: interface TopologyMgmt: deactivatePluggableDevices(int moteID)
            
            TopologyManager -> TopologyManager: interface DBTopologyMgmt: deactivateMote(int moteID)
            TopologyManager -> TopologyManager: interface DBTopologyMgmt: deactivatePluggableDevices(int moteID)
            
            -it checks for and deactivates applications that are affected by the unavailability of the
                pluggable devices (Include: UC18: Check and deactivate applications).
                seeUC18 - we dont have fucntion for deactivate application for pluggable devices, we can create one, or get 
                            first list of all apllication related to the pluggable devices, and the go to the Application Manager and 
                            call method deactivateApplication(appInstance)
                
            -It sends a notification to the primary actor (Include: UC15: Send notification).
            notify()
        

        
     UC7:
        1. The primary actor unplugs the pluggable device from its mote.
        2. A message is sent from the mote from which the pluggable device was removed to the system,
            containing the identifier of the removed pluggable device.
            Mote -> DeviceManger: interface Heartbeat : find out that pluggable device is not in heartbeat
            DeviceManager -> OnlineServiceBroker: interface TopologyMgmt deactivatePluggableDevices(int moteID)
        3. The system
        { marks the pluggable device as `inactive',
           GatewayBroker -> ApplicationManager: interface TopologyMgmt: deactivatePluggableDevices(int moteID)
        { updates the topology,
           ApplicationManager -> TopologyManager: interface TopologyMgmt: deactivatePluggableDevices(int moteID)
        { it checks and deactivates applications for which the pluggable device was essential
        (Include: UC18: Check and deactivate applications).
        seeUC18 - we dont have fucntion for deactivate application for pluggable devices, we can create one, or get 
                            first list of all apllication related to the pluggable devices, and the go to the Application Manager and 
                            call method deactivateApplication(appInstance)
        
     UC8:
        1. The primary actor indicates that they want to initialise the newly attached pluggable for use.
            InfrastructreOwnerClient -> InfrastructreOwnerFacade: interface DeviceMgmt
                                void initialisePluggableDevice()
                                        
        2. The system allows the primary actor to configure the pluggable device in the topology
            (Include: UC10: Consult and configure the topology), e.g. to set its physical location.
             See and create UC10
        3. The system marks the pluggable device as `active', and informs the primary actor that the
            pluggable is ready for use.
            InfrastructureOwnerManager -> TopologyManager: interface TopologyMgmt reactivateDevice()
            
        4. The system allows the primary actor to configure the access rights for the pluggable device
            (Include: UC9: Configure pluggable device access rights).
            See UC9
         Remarks:
            Initializing a new pluggable device may result in `inactive' applications being able to activate
            (cf. UC17: Activate an application) we need to get somehow list of applications that need just this pluggable device
            
     UC16:
     1. The primary actor indicates that he/she/they wants to consult a notification.
            ApplicationProviderClient/CustomerOrganisationClient/InfrastructureOwnerClient/SysAdminClient -> UserFacade:
                    interface Notifications: void consultNotifications()
            
     2. The system retrieves all notifications for the primary actor and presents them to the primary
        actor, e.g. as a table or list.
        UserFacade -> NotificationHandler: interface NotificationsMgmt:
                List<Notification> getNotifications(int userID)
             
                
     3. The primary actor selects a notification.
            ApplicationProviderClient/CustomerOrganisationClient/InfrastructureOwnerClient/SysAdminClient -> UserFacade:
                                Notification consultNotifications(int notificationID)
            Effect: Returns information about the notification.
            \item Created for: UC16.3
            
                                
            
     4. The system presents the details for the selected notification to the primary actor. This includes:
        { A description of the event that occurred.
        { Date and time the event occurred.
        { What triggered the event (e.g., the cause of an application that became inactive)
        { The status of the notification (e.g. `sent', `delivered', `read')
        { The communication channel by which the notification was sent
        
        
     5. The system marks the notification as `read'.
     UserFacade -> NotificationHandler: interface NotificationsMgmt:
                List<Notification> setNotificationRead(int notificationID)
     
     UC20:
        1. The primary actor indicates they want to unsubscribe from an application.
            CustomOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt
                                              void  unsubscribeFromApplications()
                 
                                                
        2. The system looks up a list of applications the primary actor is subscribed to, and presents this
            overview to the primary actor, e.g. as a list or table.
            CustomerOrganisationFacade -> ApplicationManager: interface FrontEndAppRequests:
                                             List<int> getApplications(int custOrgID)  
                                             
        3. The primary actor indicates which application they want to unsubscribe from.
             CustomOrganisationClient -> CustomerOrganisationFacade: interface SubscriptionMgmt
                                              void  unsubscribeFromApplication(int applicationInstanceID)
             Effect: Unsubscribes a customer organisation from an application.
             \item Created for: UC20.3
             
             CustomerOrganisationFacade -> SubscriptionManager: interface SubscriptionMgmt
                                              void  deleteSubscription(int applicationInstanceID, int custOrgID)
             Effect: Unsubscribes a customer organisation from an application.
             \item Created for: UC20.3
                                                         
        4. The system (i) ends the subscription for the selected application, (ii) deactivates the applica-
            tion, and (iii) constructs an invoice for outstanding payments for that application (cf. UC21:
            Send invoice).
            
            SubscriptionManager -> OtherDataDB: interface DBSubscriptionMgmt:
                                             void deleteSubscription(int custOrgID, int custOrgID)
                Effect: ends the subscription for the selected application
                \item Created for: UC20.4i
            
            SubscriptionManager -> ApplicationManager: interface FrontEndAppRequests:
                                    deactivateApplication(int applicationInstanceID, int custOrg)
                Effect: deactivates the application
                \item Created for: UC20.4ii
            
            ApplicationManager -> OtherDataDB: interface DBAppMgmt:
                                    deactivateApplication(int applicationInstanceID)
                Effect: deactivates the application
                \item Created for: UC20.4ii
            
            
            ApplicationManager  -> InvoiceManager: interface InvoiceMgmt
                                   constructInvoice(int applicationInstanceID, int custOrg)
                Effect: deactivates the application
                \item Created for: UC20.4ii
            
            
        5. The system informs the primary actor that the unsubscription was successful.
            Notify()

\subsection{Instantiation and allocation of functionality}
    This section lists the new components which instantiate our solutions
    described in the section above. For each component we note the quality
    attribute or use case that prompted us to create it. Descriptions about
    the components can be found under chapter \ref{ch:elements-datatypes}. \\

    \begin{itemize}
        \item Component: UnregisteredUserClient
              Effect: Represents the client for an unregistered user.
        \item Component: UnregisteredUserFacade
        \item Component: UnregisteredUserManager
    \end{itemize}


\subsection{Interfaces for child modules}
    This section lists new interfaces assigned to the components defined
    in the section above. Detailed information about each interface and
    its methods can be found under chapter \ref{ch:elements-datatypes}. \\

    \subsubsection{OtherDataDB}
        \begin{itemize}
            \item Registration
        \end{itemize}
    \subsubsection{UnregisteredUserClient}
        \begin{itemize}
            \item Registration
        \end{itemize}
    \subsubsection{UnregisteredUserFacade}
        \begin{itemize}
            \item Registration
        \end{itemize}
    \subsubsection{CustomerOrganisationFacade}
        \begin{itemize}
            \item EndUserMgmt
        \end{itemize}

\subsection{Data type definitions}
    This section lists the new data types introduced during this decomposition.

    \begin{itemize}
        \item Address: Represents an address of customer organisation.
    \end{itemize}
